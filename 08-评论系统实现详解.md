# 评论系统实现详解 - 交互式评论功能

## 问题背景

在博客项目中，需要实现一个完整的评论系统，包括评论发布、回复、管理、审核等功能。评论系统是用户交互的重要组成部分，需要支持嵌套评论、实时通知等特性。

## 评论系统的核心问题

### 1. 数据结构问题
- 评论层级设计
- 评论关联关系
- 评论状态管理
- 评论数据存储

### 2. 功能实现问题
- 嵌套评论显示
- 评论分页加载
- 评论审核机制
- 评论通知系统

### 3. 性能问题
- 大量评论加载
- 评论树构建
- 评论缓存策略
- 实时更新优化

## 后端实现

### 1. 评论数据模型

```go
// model/database/comment.go
package database

import (
    "time"
    "server/model/appType"
)

type Comment struct {
    BaseModel
    ArticleID    uint                    `json:"article_id" gorm:"not null;index"`
    Article      Article                 `json:"article"`
    UserID       uint                    `json:"user_id" gorm:"not null;index"`
    User         User                    `json:"user"`
    ParentID     *uint                   `json:"parent_id" gorm:"index"`
    Parent       *Comment                `json:"parent"`
    Children     []Comment               `json:"children" gorm:"foreignkey:ParentID"`
    Content      string                  `json:"content" gorm:"type:text;not null"`
    Status       appType.CommentStatus   `json:"status" gorm:"default:pending"`
    LikeCount    int64                   `json:"like_count" gorm:"default:0"`
    ReplyCount   int64                   `json:"reply_count" gorm:"default:0"`
    IP           string                  `json:"ip" gorm:"size:45"`
    UserAgent    string                  `json:"user_agent" gorm:"size:500"`
    IsAuthor     bool                    `json:"is_author" gorm:"default:false"`
    Level        int                     `json:"level" gorm:"default:0"`
    Path         string                  `json:"path" gorm:"size:1000;index"`
}

// model/appType/comment_status.go
package appType

type CommentStatus string

const (
    CommentStatusPending   CommentStatus = "pending"   // 待审核
    CommentStatusApproved  CommentStatus = "approved"  // 已通过
    CommentStatusRejected  CommentStatus = "rejected"  // 已拒绝
    CommentStatusSpam      CommentStatus = "spam"      // 垃圾评论
)

// 评论请求模型
type CreateCommentRequest struct {
    ArticleID uint   `json:"article_id" binding:"required"`
    ParentID  *uint  `json:"parent_id"`
    Content   string `json:"content" binding:"required,min=1,max=1000"`
}

type UpdateCommentRequest struct {
    Content string `json:"content" binding:"required,min=1,max=1000"`
}

// 评论响应模型
type CommentResponse struct {
    ID          uint      `json:"id"`
    ArticleID   uint      `json:"article_id"`
    UserID      uint      `json:"user_id"`
    Username    string    `json:"username"`
    Avatar      string    `json:"avatar"`
    ParentID    *uint     `json:"parent_id"`
    Content     string    `json:"content"`
    Status      string    `json:"status"`
    LikeCount   int64     `json:"like_count"`
    ReplyCount  int64     `json:"reply_count"`
    IsAuthor    bool      `json:"is_author"`
    Level       int       `json:"level"`
    Path        string    `json:"path"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
    Children    []CommentResponse `json:"children,omitempty"`
    IsLiked     bool      `json:"is_liked"`
    CanEdit     bool      `json:"can_edit"`
    CanDelete   bool      `json:"can_delete"`
}
```

### 2. 评论服务实现

```go
// service/comment.go
package service

import (
    "fmt"
    "time"
    
    "server/global"
    "server/model/database"
    "server/model/appType"
    "server/model/request"
    "server/model/response"
)

type CommentService struct{}

// 创建评论
func (s *CommentService) CreateComment(req request.CreateCommentRequest, userID uint, ip, userAgent string) (*database.Comment, error) {
    // 检查文章是否存在
    var article database.Article
    if err := global.DB.First(&article, req.ArticleID).Error; err != nil {
        return nil, fmt.Errorf("文章不存在")
    }
    
    // 检查父评论是否存在
    var parentComment *database.Comment
    if req.ParentID != nil {
        if err := global.DB.First(&parentComment, *req.ParentID).Error; err != nil {
            return nil, fmt.Errorf("父评论不存在")
        }
        
        // 检查评论层级，防止过深嵌套
        if parentComment.Level >= 3 {
            return nil, fmt.Errorf("评论层级过深")
        }
    }
    
    // 构建评论路径
    path := s.buildCommentPath(req.ParentID)
    level := s.calculateCommentLevel(req.ParentID)
    
    // 检查是否为文章作者
    isAuthor := article.UserID == userID
    
    comment := &database.Comment{
        ArticleID: req.ArticleID,
        UserID:    userID,
        ParentID:  req.ParentID,
        Content:   req.Content,
        Status:    appType.CommentStatusPending, // 默认待审核
        IP:        ip,
        UserAgent: userAgent,
        IsAuthor:  isAuthor,
        Level:     level,
        Path:      path,
    }
    
    if err := global.DB.Create(comment).Error; err != nil {
        return nil, err
    }
    
    // 更新父评论的回复数
    if req.ParentID != nil {
        global.DB.Model(&database.Comment{}).Where("id = ?", *req.ParentID).
            UpdateColumn("reply_count", gorm.Expr("reply_count + ?", 1))
    }
    
    // 更新文章的评论数
    global.DB.Model(&database.Article{}).Where("id = ?", req.ArticleID).
        UpdateColumn("comment_count", gorm.Expr("comment_count + ?", 1))
    
    return comment, nil
}

// 获取文章评论列表
func (s *CommentService) GetArticleComments(articleID uint, page, pageSize int, status appType.CommentStatus) ([]response.CommentResponse, int64, error) {
    var comments []database.Comment
    var total int64
    
    // 查询顶级评论
    query := global.DB.Where("article_id = ? AND parent_id IS NULL", articleID)
    if status != "" {
        query = query.Where("status = ?", status)
    }
    
    // 获取总数
    query.Model(&database.Comment{}).Count(&total)
    
    // 分页查询
    offset := (page - 1) * pageSize
    err := query.Preload("User").
        Preload("Children.User").
        Preload("Children.Children.User").
        Order("created_at DESC").
        Offset(offset).
        Limit(pageSize).
        Find(&comments).Error
    
    if err != nil {
        return nil, 0, err
    }
    
    // 转换为响应格式
    responses := s.convertToCommentResponses(comments)
    
    return responses, total, nil
}

// 获取评论树
func (s *CommentService) GetCommentTree(articleID uint, status appType.CommentStatus) ([]response.CommentResponse, error) {
    var comments []database.Comment
    
    query := global.DB.Where("article_id = ?", articleID)
    if status != "" {
        query = query.Where("status = ?", status)
    }
    
    err := query.Preload("User").
        Order("path ASC").
        Find(&comments).Error
    
    if err != nil {
        return nil, err
    }
    
    // 构建评论树
    commentMap := make(map[uint]*response.CommentResponse)
    var rootComments []*response.CommentResponse
    
    for _, comment := range comments {
        resp := s.convertToCommentResponse(comment)
        commentMap[comment.ID] = resp
        
        if comment.ParentID == nil {
            rootComments = append(rootComments, resp)
        } else {
            if parent, exists := commentMap[*comment.ParentID]; exists {
                parent.Children = append(parent.Children, resp)
            }
        }
    }
    
    // 转换为切片
    result := make([]response.CommentResponse, len(rootComments))
    for i, comment := range rootComments {
        result[i] = *comment
    }
    
    return result, nil
}

// 更新评论
func (s *CommentService) UpdateComment(commentID, userID uint, req request.UpdateCommentRequest) error {
    var comment database.Comment
    if err := global.DB.First(&comment, commentID).Error; err != nil {
        return fmt.Errorf("评论不存在")
    }
    
    // 检查权限
    if comment.UserID != userID {
        return fmt.Errorf("无权限修改此评论")
    }
    
    // 更新评论
    if err := global.DB.Model(&comment).Update("content", req.Content).Error; err != nil {
        return err
    }
    
    return nil
}

// 删除评论
func (s *CommentService) DeleteComment(commentID, userID uint) error {
    var comment database.Comment
    if err := global.DB.First(&comment, commentID).Error; err != nil {
        return fmt.Errorf("评论不存在")
    }
    
    // 检查权限
    if comment.UserID != userID {
        return fmt.Errorf("无权限删除此评论")
    }
    
    // 软删除评论及其子评论
    if err := global.DB.Where("id = ? OR path LIKE ?", commentID, comment.Path+"/%").Delete(&database.Comment{}).Error; err != nil {
        return err
    }
    
    // 更新父评论的回复数
    if comment.ParentID != nil {
        global.DB.Model(&database.Comment{}).Where("id = ?", *comment.ParentID).
            UpdateColumn("reply_count", gorm.Expr("reply_count - ?", 1))
    }
    
    // 更新文章的评论数
    global.DB.Model(&database.Article{}).Where("id = ?", comment.ArticleID).
        UpdateColumn("comment_count", gorm.Expr("comment_count - ?", 1))
    
    return nil
}

// 点赞评论
func (s *CommentService) LikeComment(commentID, userID uint) error {
    // 检查是否已点赞
    var like database.CommentLike
    err := global.DB.Where("comment_id = ? AND user_id = ?", commentID, userID).First(&like).Error
    
    if err == nil {
        return fmt.Errorf("已经点赞过此评论")
    }
    
    // 创建点赞记录
    like = database.CommentLike{
        CommentID: commentID,
        UserID:    userID,
    }
    
    if err := global.DB.Create(&like).Error; err != nil {
        return err
    }
    
    // 更新评论点赞数
    global.DB.Model(&database.Comment{}).Where("id = ?", commentID).
        UpdateColumn("like_count", gorm.Expr("like_count + ?", 1))
    
    return nil
}

// 取消点赞
func (s *CommentService) UnlikeComment(commentID, userID uint) error {
    // 删除点赞记录
    result := global.DB.Where("comment_id = ? AND user_id = ?", commentID, userID).Delete(&database.CommentLike{})
    if result.RowsAffected == 0 {
        return fmt.Errorf("未点赞过此评论")
    }
    
    // 更新评论点赞数
    global.DB.Model(&database.Comment{}).Where("id = ?", commentID).
        UpdateColumn("like_count", gorm.Expr("like_count - ?", 1))
    
    return nil
}

// 构建评论路径
func (s *CommentService) buildCommentPath(parentID *uint) string {
    if parentID == nil {
        return fmt.Sprintf("%d", time.Now().Unix())
    }
    
    var parent database.Comment
    if err := global.DB.First(&parent, *parentID).Error; err != nil {
        return fmt.Sprintf("%d", time.Now().Unix())
    }
    
    return fmt.Sprintf("%s/%d", parent.Path, time.Now().Unix())
}

// 计算评论层级
func (s *CommentService) calculateCommentLevel(parentID *uint) int {
    if parentID == nil {
        return 0
    }
    
    var parent database.Comment
    if err := global.DB.First(&parent, *parentID).Error; err != nil {
        return 0
    }
    
    return parent.Level + 1
}

// 转换为评论响应格式
func (s *CommentService) convertToCommentResponses(comments []database.Comment) []response.CommentResponse {
    responses := make([]response.CommentResponse, len(comments))
    for i, comment := range comments {
        responses[i] = s.convertToCommentResponse(comment)
    }
    return responses
}

// 转换为单个评论响应
func (s *CommentService) convertToCommentResponse(comment database.Comment) response.CommentResponse {
    resp := response.CommentResponse{
        ID:         comment.ID,
        ArticleID:  comment.ArticleID,
        UserID:     comment.UserID,
        Username:   comment.User.Username,
        Avatar:     comment.User.Avatar,
        ParentID:   comment.ParentID,
        Content:    comment.Content,
        Status:     string(comment.Status),
        LikeCount:  comment.LikeCount,
        ReplyCount: comment.ReplyCount,
        IsAuthor:   comment.IsAuthor,
        Level:      comment.Level,
        Path:       comment.Path,
        CreatedAt:  comment.CreatedAt,
        UpdatedAt:  comment.UpdatedAt,
    }
    
    // 递归处理子评论
    if len(comment.Children) > 0 {
        resp.Children = s.convertToCommentResponses(comment.Children)
    }
    
    return resp
}
```

### 3. 评论管理功能

```go
// service/comment_admin.go
package service

import (
    "server/global"
    "server/model/database"
    "server/model/appType"
)

type CommentAdminService struct{}

// 审核评论
func (s *CommentAdminService) ApproveComment(commentID uint) error {
    var comment database.Comment
    if err := global.DB.First(&comment, commentID).Error; err != nil {
        return fmt.Errorf("评论不存在")
    }
    
    // 更新评论状态
    if err := global.DB.Model(&comment).Update("status", appType.CommentStatusApproved).Error; err != nil {
        return err
    }
    
    // 发送通知给评论作者
    s.sendCommentNotification(comment, "approved")
    
    return nil
}

// 拒绝评论
func (s *CommentAdminService) RejectComment(commentID uint, reason string) error {
    var comment database.Comment
    if err := global.DB.First(&comment, commentID).Error; err != nil {
        return fmt.Errorf("评论不存在")
    }
    
    // 更新评论状态
    if err := global.DB.Model(&comment).Update("status", appType.CommentStatusRejected).Error; err != nil {
        return err
    }
    
    // 发送通知给评论作者
    s.sendCommentNotification(comment, "rejected", reason)
    
    return nil
}

// 标记为垃圾评论
func (s *CommentAdminService) MarkAsSpam(commentID uint) error {
    var comment database.Comment
    if err := global.DB.First(&comment, commentID).Error; err != nil {
        return fmt.Errorf("评论不存在")
    }
    
    // 更新评论状态
    if err := global.DB.Model(&comment).Update("status", appType.CommentStatusSpam).Error; err != nil {
        return err
    }
    
    return nil
}

// 批量审核评论
func (s *CommentAdminService) BatchApproveComments(commentIDs []uint) error {
    if err := global.DB.Model(&database.Comment{}).Where("id IN ?", commentIDs).
        Update("status", appType.CommentStatusApproved).Error; err != nil {
        return err
    }
    
    // 发送批量通知
    for _, commentID := range commentIDs {
        var comment database.Comment
        if err := global.DB.First(&comment, commentID).Error; err == nil {
            s.sendCommentNotification(comment, "approved")
        }
    }
    
    return nil
}

// 获取待审核评论列表
func (s *CommentAdminService) GetPendingComments(page, pageSize int) ([]response.CommentResponse, int64, error) {
    var comments []database.Comment
    var total int64
    
    // 获取总数
    global.DB.Model(&database.Comment{}).Where("status = ?", appType.CommentStatusPending).Count(&total)
    
    // 分页查询
    offset := (page - 1) * pageSize
    err := global.DB.Where("status = ?", appType.CommentStatusPending).
        Preload("User").
        Preload("Article").
        Order("created_at DESC").
        Offset(offset).
        Limit(pageSize).
        Find(&comments).Error
    
    if err != nil {
        return nil, 0, err
    }
    
    responses := s.convertToCommentResponses(comments)
    return responses, total, nil
}

// 发送评论通知
func (s *CommentAdminService) sendCommentNotification(comment database.Comment, action string, reason ...string) {
    // 这里可以集成邮件、短信或其他通知方式
    notification := map[string]interface{}{
        "type":     "comment_review",
        "user_id":  comment.UserID,
        "comment_id": comment.ID,
        "action":   action,
        "reason":   reason,
    }
    
    // 发送到消息队列或直接处理
    global.LOG.Infof("发送评论通知: %+v", notification)
}
```

## API 接口实现

### 1. 评论接口

```go
// api/comment.go
package api

import (
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
    "server/model/request"
    "server/model/response"
    "server/service"
    "server/utils"
)

type CommentApi struct{}

// 创建评论
func (api *CommentApi) CreateComment(c *gin.Context) {
    var req request.CreateCommentRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.FailWithMessage("参数错误", c)
        return
    }
    
    userID := utils.GetUserID(c)
    ip := c.ClientIP()
    userAgent := c.GetHeader("User-Agent")
    
    commentService := service.CommentService{}
    comment, err := commentService.CreateComment(req, userID, ip, userAgent)
    if err != nil {
        response.FailWithMessage("创建评论失败: "+err.Error(), c)
        return
    }
    
    response.OkWithData(comment, c)
}

// 获取文章评论列表
func (api *CommentApi) GetArticleComments(c *gin.Context) {
    articleID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))
    status := c.Query("status")
    
    commentService := service.CommentService{}
    comments, total, err := commentService.GetArticleComments(uint(articleID), page, pageSize, appType.CommentStatus(status))
    if err != nil {
        response.FailWithMessage("获取评论失败", c)
        return
    }
    
    response.OkWithData(gin.H{
        "comments": comments,
        "total":    total,
        "page":     page,
        "size":     pageSize,
    }, c)
}

// 获取评论树
func (api *CommentApi) GetCommentTree(c *gin.Context) {
    articleID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
    status := c.Query("status")
    
    commentService := service.CommentService{}
    comments, err := commentService.GetCommentTree(uint(articleID), appType.CommentStatus(status))
    if err != nil {
        response.FailWithMessage("获取评论树失败", c)
        return
    }
    
    response.OkWithData(comments, c)
}

// 更新评论
func (api *CommentApi) UpdateComment(c *gin.Context) {
    commentID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
    
    var req request.UpdateCommentRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.FailWithMessage("参数错误", c)
        return
    }
    
    userID := utils.GetUserID(c)
    commentService := service.CommentService{}
    
    if err := commentService.UpdateComment(uint(commentID), userID, req); err != nil {
        response.FailWithMessage("更新评论失败: "+err.Error(), c)
        return
    }
    
    response.OkWithMessage("更新成功", c)
}

// 删除评论
func (api *CommentApi) DeleteComment(c *gin.Context) {
    commentID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
    userID := utils.GetUserID(c)
    
    commentService := service.CommentService{}
    if err := commentService.DeleteComment(uint(commentID), userID); err != nil {
        response.FailWithMessage("删除评论失败: "+err.Error(), c)
        return
    }
    
    response.OkWithMessage("删除成功", c)
}

// 点赞评论
func (api *CommentApi) LikeComment(c *gin.Context) {
    commentID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
    userID := utils.GetUserID(c)
    
    commentService := service.CommentService{}
    if err := commentService.LikeComment(uint(commentID), userID); err != nil {
        response.FailWithMessage("点赞失败: "+err.Error(), c)
        return
    }
    
    response.OkWithMessage("点赞成功", c)
}

// 取消点赞
func (api *CommentApi) UnlikeComment(c *gin.Context) {
    commentID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
    userID := utils.GetUserID(c)
    
    commentService := service.CommentService{}
    if err := commentService.UnlikeComment(uint(commentID), userID); err != nil {
        response.FailWithMessage("取消点赞失败: "+err.Error(), c)
        return
    }
    
    response.OkWithMessage("取消点赞成功", c)
}
```

### 2. 评论管理接口

```go
// api/comment_admin.go
package api

import (
    "strconv"
    
    "github.com/gin-gonic/gin"
    "server/model/response"
    "server/service"
    "server/utils"
)

type CommentAdminApi struct{}

// 审核评论
func (api *CommentAdminApi) ApproveComment(c *gin.Context) {
    commentID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
    
    commentAdminService := service.CommentAdminService{}
    if err := commentAdminService.ApproveComment(uint(commentID)); err != nil {
        response.FailWithMessage("审核失败: "+err.Error(), c)
        return
    }
    
    response.OkWithMessage("审核通过", c)
}

// 拒绝评论
func (api *CommentAdminApi) RejectComment(c *gin.Context) {
    commentID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
    reason := c.PostForm("reason")
    
    commentAdminService := service.CommentAdminService{}
    if err := commentAdminService.RejectComment(uint(commentID), reason); err != nil {
        response.FailWithMessage("拒绝失败: "+err.Error(), c)
        return
    }
    
    response.OkWithMessage("已拒绝", c)
}

// 标记为垃圾评论
func (api *CommentAdminApi) MarkAsSpam(c *gin.Context) {
    commentID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
    
    commentAdminService := service.CommentAdminService{}
    if err := commentAdminService.MarkAsSpam(uint(commentID)); err != nil {
        response.FailWithMessage("操作失败: "+err.Error(), c)
        return
    }
    
    response.OkWithMessage("已标记为垃圾评论", c)
}

// 获取待审核评论列表
func (api *CommentAdminApi) GetPendingComments(c *gin.Context) {
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))
    
    commentAdminService := service.CommentAdminService{}
    comments, total, err := commentAdminService.GetPendingComments(page, pageSize)
    if err != nil {
        response.FailWithMessage("获取评论失败", c)
        return
    }
    
    response.OkWithData(gin.H{
        "comments": comments,
        "total":    total,
        "page":     page,
        "size":     pageSize,
    }, c)
}
```

## 前端实现

### 1. 评论组件

```vue
<!-- components/CommentList.vue -->
<template>
  <div class="comment-list">
    <!-- 评论输入框 -->
    <div class="comment-input">
      <el-input
        v-model="commentContent"
        type="textarea"
        :rows="3"
        placeholder="写下你的评论..."
        :maxlength="1000"
        show-word-limit
      />
      <div class="comment-actions">
        <el-button type="primary" @click="submitComment" :loading="submitting">
          发表评论
        </el-button>
      </div>
    </div>
    
    <!-- 评论列表 -->
    <div class="comments">
      <div v-if="loading" class="loading">
        <el-skeleton :rows="3" animated />
      </div>
      
      <div v-else-if="comments.length === 0" class="no-comments">
        <el-empty description="暂无评论" />
      </div>
      
      <div v-else class="comment-items">
        <CommentItem
          v-for="comment in comments"
          :key="comment.id"
          :comment="comment"
          @reply="handleReply"
          @edit="handleEdit"
          @delete="handleDelete"
          @like="handleLike"
        />
      </div>
      
      <!-- 分页 -->
      <div v-if="total > pageSize" class="pagination">
        <el-pagination
          v-model:current-page="currentPage"
          v-model:page-size="pageSize"
          :total="total"
          :page-sizes="[10, 20, 50]"
          layout="total, sizes, prev, pager, next"
          @size-change="handleSizeChange"
          @current-change="handleCurrentChange"
        />
      </div>
    </div>
    
    <!-- 回复对话框 -->
    <el-dialog v-model="replyDialogVisible" title="回复评论" width="500px">
      <el-input
        v-model="replyContent"
        type="textarea"
        :rows="3"
        placeholder="写下你的回复..."
        :maxlength="1000"
        show-word-limit
      />
      <template #footer>
        <el-button @click="replyDialogVisible = false">取消</el-button>
        <el-button type="primary" @click="submitReply" :loading="submitting">
          回复
        </el-button>
      </template>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed } from 'vue'
import { ElMessage } from 'element-plus'
import CommentItem from './CommentItem.vue'
import { createComment, getArticleComments } from '@/api/comment'
import type { Comment } from '@/types/comment'

interface Props {
  articleId: number
}

const props = defineProps<Props>()

// 状态
const comments = ref<Comment[]>([])
const total = ref(0)
const loading = ref(false)
const submitting = ref(false)
const currentPage = ref(1)
const pageSize = ref(20)

// 评论输入
const commentContent = ref('')
const replyContent = ref('')
const replyDialogVisible = ref(false)
const replyToComment = ref<Comment | null>(null)

// 获取评论列表
const fetchComments = async () => {
  loading.value = true
  try {
    const response = await getArticleComments(props.articleId, {
      page: currentPage.value,
      pageSize: pageSize.value,
    })
    comments.value = response.comments
    total.value = response.total
  } catch (error) {
    ElMessage.error('获取评论失败')
  } finally {
    loading.value = false
  }
}

// 提交评论
const submitComment = async () => {
  if (!commentContent.value.trim()) {
    ElMessage.warning('请输入评论内容')
    return
  }
  
  submitting.value = true
  try {
    await createComment({
      articleId: props.articleId,
      content: commentContent.value,
    })
    
    ElMessage.success('评论发表成功')
    commentContent.value = ''
    await fetchComments()
  } catch (error) {
    ElMessage.error('评论发表失败')
  } finally {
    submitting.value = false
  }
}

// 处理回复
const handleReply = (comment: Comment) => {
  replyToComment.value = comment
  replyDialogVisible.value = true
}

// 提交回复
const submitReply = async () => {
  if (!replyContent.value.trim()) {
    ElMessage.warning('请输入回复内容')
    return
  }
  
  if (!replyToComment.value) return
  
  submitting.value = true
  try {
    await createComment({
      articleId: props.articleId,
      parentId: replyToComment.value.id,
      content: replyContent.value,
    })
    
    ElMessage.success('回复发表成功')
    replyContent.value = ''
    replyDialogVisible.value = false
    replyToComment.value = null
    await fetchComments()
  } catch (error) {
    ElMessage.error('回复发表失败')
  } finally {
    submitting.value = false
  }
}

// 处理编辑
const handleEdit = (comment: Comment) => {
  // 实现编辑功能
}

// 处理删除
const handleDelete = async (comment: Comment) => {
  // 实现删除功能
}

// 处理点赞
const handleLike = async (comment: Comment) => {
  // 实现点赞功能
}

// 分页处理
const handleSizeChange = (size: number) => {
  pageSize.value = size
  currentPage.value = 1
  fetchComments()
}

const handleCurrentChange = (page: number) => {
  currentPage.value = page
  fetchComments()
}

onMounted(() => {
  fetchComments()
})
</script>

<style scoped>
.comment-list {
  margin-top: 30px;
}

.comment-input {
  margin-bottom: 30px;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
}

.comment-actions {
  margin-top: 15px;
  text-align: right;
}

.comments {
  margin-bottom: 30px;
}

.comment-items {
  margin-bottom: 20px;
}

.pagination {
  text-align: center;
  margin-top: 30px;
}

.loading {
  padding: 40px;
}

.no-comments {
  padding: 60px 0;
}
</style>
```

### 2. 评论项组件

```vue
<!-- components/CommentItem.vue -->
<template>
  <div class="comment-item" :class="{ 'comment-reply': comment.level > 0 }">
    <div class="comment-avatar">
      <el-avatar :src="comment.avatar" :size="40">
        {{ comment.username.charAt(0).toUpperCase() }}
      </el-avatar>
    </div>
    
    <div class="comment-content">
      <div class="comment-header">
        <span class="username">{{ comment.username }}</span>
        <span v-if="comment.isAuthor" class="author-badge">作者</span>
        <span class="time">{{ formatTime(comment.createdAt) }}</span>
      </div>
      
      <div class="comment-text">{{ comment.content }}</div>
      
      <div class="comment-actions">
        <el-button
          type="text"
          size="small"
          @click="$emit('like', comment)"
          :class="{ 'liked': comment.isLiked }"
        >
          <el-icon><ThumbsUp /></el-icon>
          {{ comment.likeCount }}
        </el-button>
        
        <el-button
          type="text"
          size="small"
          @click="$emit('reply', comment)"
        >
          回复
        </el-button>
        
        <el-button
          v-if="comment.canEdit"
          type="text"
          size="small"
          @click="$emit('edit', comment)"
        >
          编辑
        </el-button>
        
        <el-button
          v-if="comment.canDelete"
          type="text"
          size="small"
          @click="handleDelete"
        >
          删除
        </el-button>
      </div>
      
      <!-- 子评论 -->
      <div v-if="comment.children && comment.children.length > 0" class="comment-children">
        <CommentItem
          v-for="child in comment.children"
          :key="child.id"
          :comment="child"
          @reply="$emit('reply', $event)"
          @edit="$emit('edit', $event)"
          @delete="$emit('delete', $event)"
          @like="$emit('like', $event)"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { ElMessageBox } from 'element-plus'
import { ThumbsUp } from '@element-plus/icons-vue'
import { formatTime } from '@/utils/time'
import type { Comment } from '@/types/comment'

interface Props {
  comment: Comment
}

const props = defineProps<Props>()

const emit = defineEmits<{
  reply: [comment: Comment]
  edit: [comment: Comment]
  delete: [comment: Comment]
  like: [comment: Comment]
}>()

// 处理删除
const handleDelete = async () => {
  try {
    await ElMessageBox.confirm('确定要删除这条评论吗？', '确认删除', {
      type: 'warning',
    })
    emit('delete', props.comment)
  } catch {
    // 用户取消删除
  }
}
</script>

<style scoped>
.comment-item {
  display: flex;
  margin-bottom: 20px;
  padding: 15px;
  border: 1px solid #e4e7ed;
  border-radius: 8px;
  transition: all 0.3s;
}

.comment-item:hover {
  border-color: #409eff;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.comment-reply {
  margin-left: 40px;
  background: #f8f9fa;
}

.comment-avatar {
  margin-right: 15px;
  flex-shrink: 0;
}

.comment-content {
  flex: 1;
}

.comment-header {
  margin-bottom: 8px;
}

.username {
  font-weight: 600;
  color: #303133;
  margin-right: 8px;
}

.author-badge {
  background: #409eff;
  color: white;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 12px;
  margin-right: 8px;
}

.time {
  color: #909399;
  font-size: 12px;
}

.comment-text {
  line-height: 1.6;
  color: #606266;
  margin-bottom: 10px;
}

.comment-actions {
  display: flex;
  gap: 15px;
}

.comment-actions .el-button {
  padding: 0;
  color: #909399;
}

.comment-actions .el-button:hover {
  color: #409eff;
}

.comment-actions .liked {
  color: #409eff;
}

.comment-children {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #e4e7ed;
}
</style>
```

## 总结

评论系统是博客平台的重要组成部分，需要综合考虑功能完整性、性能优化和用户体验。

**关键要点：**
- 评论数据结构设计
- 嵌套评论实现
- 评论管理功能
- 实时通知系统
- 性能优化策略

**最佳实践：**
1. **数据结构**: 合理设计评论层级和关联关系
2. **功能完整**: 支持评论、回复、点赞、管理等功能
3. **用户体验**: 友好的交互界面和实时反馈
4. **性能优化**: 分页加载、缓存策略、异步处理
5. **安全考虑**: 评论审核、垃圾评论过滤、权限控制

通过合理的评论系统实现，可以为博客平台提供良好的用户交互体验。

---

*本文详细介绍了评论系统的实现原理、设计思路和最佳实践，希望对您的开发工作有所帮助。*
