# 文件上传功能实现详解 - 安全可靠的文件处理

## 问题背景

在博客项目中，需要实现图片、文件的上传功能，包括头像上传、文章配图、附件上传等。需要考虑文件安全、存储方式、性能优化等多个方面的问题。

## 文件上传的核心问题

### 1. 安全性问题
- 文件类型验证
- 文件大小限制
- 恶意文件检测
- 上传权限控制

### 2. 存储问题
- 本地存储 vs 云存储
- 文件命名策略
- 目录结构设计
- 存储空间管理

### 3. 性能问题
- 大文件处理
- 并发上传
- 上传进度显示
- 文件压缩优化

## 后端实现

### 1. 文件上传配置

```go
// config/conf_upload.go
package config

type Upload struct {
    MaxSize      int64  `mapstructure:"max-size" json:"max-size" yaml:"max-size"`
    MaxFiles     int    `mapstructure:"max-files" json:"max-files" yaml:"max-files"`
    AllowedTypes string `mapstructure:"allowed-types" json:"allowed-types" yaml:"allowed-types"`
    StoragePath  string `mapstructure:"storage-path" json:"storage-path" yaml:"storage-path"`
    Domain       string `mapstructure:"domain" json:"domain" yaml:"domain"`
}

// config.yaml
upload:
  max-size: 10485760  # 10MB
  max-files: 10
  allowed-types: "jpg,jpeg,png,gif,webp,pdf,doc,docx"
  storage-path: "./uploads"
  domain: "http://localhost:8080"
```

### 2. 文件模型定义

```go
// model/database/media.go
package database

import (
    "time"
    "server/model/appType"
)

type Media struct {
    BaseModel
    UserID      uint                    `json:"user_id" gorm:"not null"`
    User        User                    `json:"user"`
    Filename    string                  `json:"filename" gorm:"not null"`
    OriginalName string                 `json:"original_name" gorm:"not null"`
    FilePath    string                  `json:"file_path" gorm:"not null"`
    FileSize    int64                   `json:"file_size" gorm:"not null"`
    FileType    string                  `json:"file_type" gorm:"not null"`
    MimeType    string                  `json:"mime_type" gorm:"not null"`
    StorageType appType.ImageStorage    `json:"storage_type" gorm:"not null;default:local"`
    URL         string                  `json:"url" gorm:"not null"`
    Hash        string                  `json:"hash" gorm:"uniqueIndex"`
    Width       int                     `json:"width,omitempty"`
    Height      int                     `json:"height,omitempty"`
    Status      string                  `json:"status" gorm:"default:active"`
}

// model/appType/image_storage.go
package appType

type ImageStorage string

const (
    LocalStorage ImageStorage = "local"
    QiniuStorage ImageStorage = "qiniu"
    AliyunStorage ImageStorage = "aliyun"
    TencentStorage ImageStorage = "tencent"
)
```

### 3. 文件上传服务

```go
// service/upload.go
package service

import (
    "crypto/md5"
    "fmt"
    "io"
    "mime/multipart"
    "os"
    "path/filepath"
    "strings"
    "time"
    
    "github.com/gin-gonic/gin"
    "server/global"
    "server/model/database"
    "server/model/appType"
)

type UploadService struct{}

// 上传文件
func (s *UploadService) UploadFile(file *multipart.FileHeader, userID uint) (*database.Media, error) {
    // 1. 验证文件
    if err := s.validateFile(file); err != nil {
        return nil, err
    }
    
    // 2. 生成文件信息
    fileInfo, err := s.generateFileInfo(file)
    if err != nil {
        return nil, err
    }
    
    // 3. 检查文件是否已存在
    if existingMedia := s.checkFileExists(fileInfo.Hash); existingMedia != nil {
        return existingMedia, nil
    }
    
    // 4. 保存文件
    if err := s.saveFile(file, fileInfo); err != nil {
        return nil, err
    }
    
    // 5. 创建媒体记录
    media := &database.Media{
        UserID:       userID,
        Filename:     fileInfo.Filename,
        OriginalName: file.Filename,
        FilePath:     fileInfo.FilePath,
        FileSize:     file.Size,
        FileType:     fileInfo.FileType,
        MimeType:     fileInfo.MimeType,
        StorageType:  appType.LocalStorage,
        URL:          fileInfo.URL,
        Hash:         fileInfo.Hash,
        Width:        fileInfo.Width,
        Height:       fileInfo.Height,
    }
    
    if err := global.DB.Create(media).Error; err != nil {
        os.Remove(fileInfo.FilePath)
        return nil, err
    }
    
    return media, nil
}

// 验证文件
func (s *UploadService) validateFile(file *multipart.FileHeader) error {
    // 检查文件大小
    if file.Size > global.CONFIG.Upload.MaxSize {
        return fmt.Errorf("文件大小超过限制: %d bytes", global.CONFIG.Upload.MaxSize)
    }
    
    // 检查文件类型
    ext := strings.ToLower(filepath.Ext(file.Filename))
    allowedTypes := strings.Split(global.CONFIG.Upload.AllowedTypes, ",")
    
    allowed := false
    for _, allowedType := range allowedTypes {
        if "."+strings.TrimSpace(allowedType) == ext {
            allowed = true
            break
        }
    }
    
    if !allowed {
        return fmt.Errorf("不支持的文件类型: %s", ext)
    }
    
    return nil
}

// 生成文件信息
func (s *UploadService) generateFileInfo(file *multipart.FileHeader) (*FileInfo, error) {
    // 计算文件哈希
    hash, err := s.calculateFileHash(file)
    if err != nil {
        return nil, err
    }
    
    // 生成文件名
    ext := filepath.Ext(file.Filename)
    filename := hash + ext
    
    // 生成存储路径
    now := time.Now()
    relativePath := fmt.Sprintf("%d/%d/%d", now.Year(), now.Month(), now.Day())
    fullPath := filepath.Join(global.CONFIG.Upload.StoragePath, relativePath)
    
    // 创建目录
    if err := os.MkdirAll(fullPath, 0755); err != nil {
        return nil, err
    }
    
    filePath := filepath.Join(fullPath, filename)
    url := fmt.Sprintf("%s/uploads/%s/%s", global.CONFIG.Upload.Domain, relativePath, filename)
    
    return &FileInfo{
        Filename:  filename,
        FilePath:  filePath,
        FileType:  strings.TrimPrefix(filepath.Ext(file.Filename), "."),
        MimeType:  file.Header.Get("Content-Type"),
        URL:       url,
        Hash:      hash,
    }, nil
}

// 计算文件哈希
func (s *UploadService) calculateFileHash(file *multipart.FileHeader) (string, error) {
    src, err := file.Open()
    if err != nil {
        return "", err
    }
    defer src.Close()
    
    hash := md5.New()
    if _, err := io.Copy(hash, src); err != nil {
        return "", err
    }
    
    return fmt.Sprintf("%x", hash.Sum(nil)), nil
}

// 保存文件
func (s *UploadService) saveFile(file *multipart.FileHeader, fileInfo *FileInfo) error {
    src, err := file.Open()
    if err != nil {
        return err
    }
    defer src.Close()
    
    dst, err := os.Create(fileInfo.FilePath)
    if err != nil {
        return err
    }
    defer dst.Close()
    
    _, err = io.Copy(dst, src)
    return err
}

// 检查文件是否已存在
func (s *UploadService) checkFileExists(hash string) *database.Media {
    var media database.Media
    if err := global.DB.Where("hash = ?", hash).First(&media).Error; err == nil {
        return &media
    }
    return nil
}

type FileInfo struct {
    Filename  string
    FilePath  string
    FileType  string
    MimeType  string
    URL       string
    Hash      string
    Width     int
    Height    int
}
```

## API 接口实现

### 1. 文件上传接口

```go
// api/upload.go
package api

import (
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
    "server/model/response"
    "server/service"
)

type UploadApi struct{}

// 上传单个文件
func (api *UploadApi) UploadFile(c *gin.Context) {
    // 获取用户信息
    userID := utils.GetUserID(c)
    
    // 获取上传的文件
    file, err := c.FormFile("file")
    if err != nil {
        response.FailWithMessage("获取文件失败", c)
        return
    }
    
    // 执行上传
    uploadService := service.UploadService{}
    media, err := uploadService.UploadFile(file, userID)
    if err != nil {
        response.FailWithMessage("上传失败: "+err.Error(), c)
        return
    }
    
    response.OkWithData(media, c)
}

// 批量上传文件
func (api *UploadApi) BatchUploadFiles(c *gin.Context) {
    // 获取用户信息
    userID := utils.GetUserID(c)
    
    // 获取上传的文件
    form, err := c.MultipartForm()
    if err != nil {
        response.FailWithMessage("获取文件失败", c)
        return
    }
    
    files := form.File["files"]
    if len(files) == 0 {
        response.FailWithMessage("没有选择文件", c)
        return
    }
    
    // 执行批量上传
    uploadService := service.UploadService{}
    results, errors := uploadService.BatchUploadFiles(files, userID)
    
    response.OkWithData(gin.H{
        "success_count": len(results),
        "error_count":   len(errors),
        "results":       results,
        "errors":        errors,
    }, c)
}

// 获取文件列表
func (api *UploadApi) GetFileList(c *gin.Context) {
    userID := utils.GetUserID(c)
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))
    
    var medias []database.Media
    var total int64
    
    // 查询总数
    global.DB.Model(&database.Media{}).Where("user_id = ?", userID).Count(&total)
    
    // 查询列表
    offset := (page - 1) * pageSize
    global.DB.Where("user_id = ?", userID).
        Order("created_at DESC").
        Offset(offset).
        Limit(pageSize).
        Find(&medias)
    
    response.OkWithData(gin.H{
        "list":  medias,
        "total": total,
        "page":  page,
        "size":  pageSize,
    }, c)
}
```

## 安全措施

### 1. 文件类型验证

```go
// utils/file_validator.go
package utils

import (
    "bytes"
    "io"
    "mime/multipart"
)

// 文件魔数验证
var fileSignatures = map[string][]byte{
    "jpg":  {0xFF, 0xD8, 0xFF},
    "png":  {0x89, 0x50, 0x4E, 0x47},
    "gif":  {0x47, 0x49, 0x46},
    "webp": {0x52, 0x49, 0x46, 0x46},
    "pdf":  {0x25, 0x50, 0x44, 0x46},
}

// 验证文件签名
func ValidateFileSignature(file *multipart.FileHeader, expectedType string) error {
    src, err := file.Open()
    if err != nil {
        return err
    }
    defer src.Close()
    
    signature, exists := fileSignatures[expectedType]
    if !exists {
        return fmt.Errorf("不支持的文件类型")
    }
    
    buffer := make([]byte, len(signature))
    _, err = io.ReadFull(src, buffer)
    if err != nil {
        return err
    }
    
    if !bytes.Equal(buffer, signature) {
        return fmt.Errorf("文件签名不匹配")
    }
    
    return nil
}
```

### 2. 文件大小限制中间件

```go
// middleware/upload_limit.go
package middleware

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "server/global"
)

// 文件大小限制中间件
func UploadLimit() gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        c.Request.Body = http.MaxBytesReader(
            c.Writer,
            c.Request.Body,
            global.CONFIG.Upload.MaxSize,
        )
        
        c.Next()
    })
}
```

## 前端集成

### 1. 文件上传工具

```typescript
// utils/upload.ts
import request from './request'

export interface UploadResponse {
  id: number
  filename: string
  original_name: string
  url: string
  file_size: number
  file_type: string
  width?: number
  height?: number
}

// 上传单个文件
export const uploadFile = (file: File): Promise<UploadResponse> => {
  const formData = new FormData()
  formData.append('file', file)
  
  return request.post('/upload/file', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  })
}

// 批量上传文件
export const batchUploadFiles = (files: File[]): Promise<{
  success_count: number
  error_count: number
  results: UploadResponse[]
  errors: any[]
}> => {
  const formData = new FormData()
  files.forEach(file => {
    formData.append('files', file)
  })
  
  return request.post('/upload/files', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  })
}

// 获取文件列表
export const getFileList = (params: {
  page?: number
  page_size?: number
}) => {
  return request.get('/upload/list', { params })
}
```

### 2. 上传进度处理

```typescript
// utils/uploadProgress.ts
export class UploadProgress {
  private xhr: XMLHttpRequest | null = null
  
  uploadWithProgress(
    url: string,
    formData: FormData,
    onProgress?: (progress: number) => void,
    onSuccess?: (response: any) => void,
    onError?: (error: any) => void
  ) {
    this.xhr = new XMLHttpRequest()
    
    this.xhr.upload.addEventListener('progress', (event) => {
      if (event.lengthComputable && onProgress) {
        const progress = (event.loaded / event.total) * 100
        onProgress(progress)
      }
    })
    
    this.xhr.addEventListener('load', () => {
      if (this.xhr?.status === 200 && onSuccess) {
        const response = JSON.parse(this.xhr.responseText)
        onSuccess(response)
      } else if (onError) {
        onError(new Error('上传失败'))
      }
    })
    
    this.xhr.addEventListener('error', () => {
      if (onError) {
        onError(new Error('网络错误'))
      }
    })
    
    this.xhr.open('POST', url)
    this.xhr.setRequestHeader('Authorization', `Bearer ${localStorage.getItem('token')}`)
    this.xhr.send(formData)
  }
  
  cancel() {
    if (this.xhr) {
      this.xhr.abort()
      this.xhr = null
    }
  }
}
```

## 总结

文件上传功能是博客系统的重要组成部分，需要考虑安全性、性能和用户体验等多个方面。

**关键要点：**
- 文件类型和内容验证
- 文件大小和数量限制
- 安全的文件命名和存储
- 图片处理和压缩优化
- 云存储集成
- 异步处理和性能优化

**最佳实践：**
1. **安全验证**: 严格验证文件类型、大小和内容
2. **存储策略**: 合理选择本地存储或云存储
3. **性能优化**: 图片压缩、异步处理、进度显示
4. **错误处理**: 完善的错误处理和监控机制
5. **用户体验**: 上传进度、预览功能、批量操作

通过合理的文件上传实现，可以为博客系统提供安全、高效的文件管理功能。

---

*本文详细介绍了文件上传功能的实现原理、安全措施和性能优化方法，希望对您的开发工作有所帮助。*
