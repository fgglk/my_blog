# Elasticsearch 搜索功能实现详解 - 全文搜索实践

## 问题背景

在博客项目中，需要实现文章的全文搜索功能，包括标题、内容、标签的模糊匹配。传统的数据库 LIKE 查询性能较差，无法满足复杂的搜索需求，因此引入 Elasticsearch 作为搜索引擎。

## 什么是 Elasticsearch？

### Elasticsearch 基本概念

Elasticsearch 是一个分布式、RESTful 风格的搜索和分析引擎，基于 Apache Lucene 构建。它能够快速、近实时地存储、搜索和分析大量数据。

### Elasticsearch 的优势

1. **高性能**: 基于倒排索引，搜索速度极快
2. **全文搜索**: 支持复杂的文本搜索和分析
3. **分布式**: 支持水平扩展，处理大规模数据
4. **实时性**: 近实时的搜索和分析能力
5. **丰富的查询**: 支持多种查询类型和聚合

## Go 中集成 Elasticsearch

### 1. 安装和配置

```go
// go.mod
require (
    github.com/elastic/go-elasticsearch/v8 v8.15.0
)

// initialize/es.go
package initialize

import (
    "context"
    "log"
    
    "github.com/elastic/go-elasticsearch/v8"
    "server/global"
)

func InitEs() {
    cfg := elasticsearch.Config{
        Addresses: []string{
            global.CONFIG.Elasticsearch.Address,
        },
        Username: global.CONFIG.Elasticsearch.Username,
        Password: global.CONFIG.Elasticsearch.Password,
    }
    
    es, err := elasticsearch.NewClient(cfg)
    if err != nil {
        log.Fatalf("Error creating Elasticsearch client: %s", err)
    }
    
    // 测试连接
    res, err := es.Info()
    if err != nil {
        log.Fatalf("Error getting Elasticsearch info: %s", err)
    }
    defer res.Body.Close()
    
    global.ES = es
    log.Println("Elasticsearch connected successfully")
}
```

### 2. 创建索引映射

```go
// service/es_index.go
package service

import (
    "context"
    "strings"
    
    "github.com/elastic/go-elasticsearch/v8"
    "server/global"
)

const ArticleIndex = "articles"

// 创建文章索引
func CreateArticleIndex() error {
    mapping := `{
        "settings": {
            "number_of_shards": 1,
            "number_of_replicas": 0,
            "analysis": {
                "analyzer": {
                    "ik_max_word": {
                        "type": "ik_max_word"
                    },
                    "ik_smart": {
                        "type": "ik_smart"
                    }
                }
            }
        },
        "mappings": {
            "properties": {
                "id": {
                    "type": "long"
                },
                "title": {
                    "type": "text",
                    "analyzer": "ik_max_word",
                    "search_analyzer": "ik_smart",
                    "fields": {
                        "keyword": {
                            "type": "keyword",
                            "ignore_above": 256
                        }
                    }
                },
                "content": {
                    "type": "text",
                    "analyzer": "ik_max_word",
                    "search_analyzer": "ik_smart"
                },
                "summary": {
                    "type": "text",
                    "analyzer": "ik_max_word"
                },
                "tags": {
                    "type": "keyword"
                },
                "category": {
                    "type": "keyword"
                },
                "author": {
                    "type": "keyword"
                },
                "status": {
                    "type": "keyword"
                },
                "view_count": {
                    "type": "long"
                },
                "like_count": {
                    "type": "long"
                },
                "comment_count": {
                    "type": "long"
                },
                "created_at": {
                    "type": "date",
                    "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"
                },
                "updated_at": {
                    "type": "date",
                    "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"
                }
            }
        }
    }`
    
    // 检查索引是否存在
    exists, err := global.ES.Indices.Exists([]string{ArticleIndex})
    if err != nil {
        return err
    }
    
    if exists.StatusCode == 404 {
        // 创建索引
        res, err := global.ES.Indices.Create(
            ArticleIndex,
            global.ES.Indices.Create.WithBody(strings.NewReader(mapping)),
        )
        if err != nil {
            return err
        }
        defer res.Body.Close()
        
        if res.IsError() {
            return fmt.Errorf("Error creating index: %s", res.String())
        }
    }
    
    return nil
}

// 删除索引
func DeleteArticleIndex() error {
    res, err := global.ES.Indices.Delete([]string{ArticleIndex})
    if err != nil {
        return err
    }
    defer res.Body.Close()
    
    if res.IsError() && res.StatusCode != 404 {
        return fmt.Errorf("Error deleting index: %s", res.String())
    }
    
    return nil
}
```

### 3. 文章数据模型

```go
// model/es/article.go
package es

import (
    "time"
)

type Article struct {
    ID           uint      `json:"id"`
    Title        string    `json:"title"`
    Content      string    `json:"content"`
    Summary      string    `json:"summary"`
    Tags         []string  `json:"tags"`
    Category     string    `json:"category"`
    Author       string    `json:"author"`
    Status       string    `json:"status"`
    ViewCount    int64     `json:"view_count"`
    LikeCount    int64     `json:"like_count"`
    CommentCount int64     `json:"comment_count"`
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}

type ArticleSearchResult struct {
    ID           uint      `json:"id"`
    Title        string    `json:"title"`
    Summary      string    `json:"summary"`
    Tags         []string  `json:"tags"`
    Category     string    `json:"category"`
    Author       string    `json:"author"`
    ViewCount    int64     `json:"view_count"`
    LikeCount    int64     `json:"like_count"`
    CommentCount int64     `json:"comment_count"`
    CreatedAt    time.Time `json:"created_at"`
    Score        float64   `json:"score"`
    Highlight    []string  `json:"highlight,omitempty"`
}

type SearchResponse struct {
    Total   int64                  `json:"total"`
    Results []ArticleSearchResult  `json:"results"`
    Aggs    map[string]interface{} `json:"aggs,omitempty"`
}
```

## 搜索功能实现

### 1. 基础搜索功能

```go
// service/article_search.go
package service

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "strings"
    
    "github.com/elastic/go-elasticsearch/v8"
    "server/global"
    "server/model/es"
)

// 搜索文章
func SearchArticles(query string, page, pageSize int, filters map[string]interface{}) (*es.SearchResponse, error) {
    var buf bytes.Buffer
    
    // 构建搜索查询
    searchQuery := buildSearchQuery(query, filters)
    
    if err := json.NewEncoder(&buf).Encode(searchQuery); err != nil {
        return nil, err
    }
    
    // 执行搜索
    res, err := global.ES.Search(
        global.ES.Search.WithContext(context.Background()),
        global.ES.Search.WithIndex(es.ArticleIndex),
        global.ES.Search.WithBody(&buf),
        global.ES.Search.WithTrackTotalHits(true),
        global.ES.Search.WithFrom((page-1)*pageSize),
        global.ES.Search.WithSize(pageSize),
        global.ES.Search.WithSort("_score:desc", "created_at:desc"),
    )
    
    if err != nil {
        return nil, err
    }
    defer res.Body.Close()
    
    if res.IsError() {
        return nil, fmt.Errorf("Error searching: %s", res.String())
    }
    
    // 解析搜索结果
    var result map[string]interface{}
    if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
        return nil, err
    }
    
    return parseSearchResult(result)
}

// 构建搜索查询
func buildSearchQuery(query string, filters map[string]interface{}) map[string]interface{} {
    must := []map[string]interface{}{
        {
            "term": map[string]interface{}{
                "status": "published",
            },
        },
    }
    
    // 添加全文搜索
    if query != "" {
        must = append(must, map[string]interface{}{
            "multi_match": map[string]interface{}{
                "query":  query,
                "fields": []string{"title^3", "content^2", "summary^1"},
                "type":   "best_fields",
                "fuzziness": "AUTO",
            },
        })
    }
    
    // 添加过滤条件
    if filters != nil {
        for field, value := range filters {
            if value != nil && value != "" {
                if field == "tags" || field == "category" {
                    must = append(must, map[string]interface{}{
                        "term": map[string]interface{}{
                            field: value,
                        },
                    })
                } else if field == "date_range" {
                    if dateRange, ok := value.(map[string]interface{}); ok {
                        must = append(must, map[string]interface{}{
                            "range": map[string]interface{}{
                                "created_at": dateRange,
                            },
                        })
                    }
                }
            }
        }
    }
    
    return map[string]interface{}{
        "query": map[string]interface{}{
            "bool": map[string]interface{}{
                "must": must,
            },
        },
        "highlight": map[string]interface{}{
            "fields": map[string]interface{}{
                "title": map[string]interface{}{
                    "pre_tags":  []string{"<em>"},
                    "post_tags": []string{"</em>"},
                },
                "content": map[string]interface{}{
                    "pre_tags":  []string{"<em>"},
                    "post_tags": []string{"</em>"},
                    "fragment_size": 150,
                    "number_of_fragments": 3,
                },
            },
        },
    }
}

// 解析搜索结果
func parseSearchResult(result map[string]interface{}) (*es.SearchResponse, error) {
    hits, ok := result["hits"].(map[string]interface{})
    if !ok {
        return nil, fmt.Errorf("invalid response format")
    }
    
    total, ok := hits["total"].(map[string]interface{})
    if !ok {
        return nil, fmt.Errorf("invalid total format")
    }
    
    totalValue, ok := total["value"].(float64)
    if !ok {
        return nil, fmt.Errorf("invalid total value")
    }
    
    hitList, ok := hits["hits"].([]interface{})
    if !ok {
        return nil, fmt.Errorf("invalid hits format")
    }
    
    var results []es.ArticleSearchResult
    for _, hit := range hitList {
        hitMap, ok := hit.(map[string]interface{})
        if !ok {
            continue
        }
        
        source, ok := hitMap["_source"].(map[string]interface{})
        if !ok {
            continue
        }
        
        score, _ := hitMap["_score"].(float64)
        
        article := es.ArticleSearchResult{
            ID:           uint(source["id"].(float64)),
            Title:        source["title"].(string),
            Summary:      source["summary"].(string),
            Category:     source["category"].(string),
            Author:       source["author"].(string),
            ViewCount:    int64(source["view_count"].(float64)),
            LikeCount:    int64(source["like_count"].(float64)),
            CommentCount: int64(source["comment_count"].(float64)),
            Score:        score,
        }
        
        // 解析标签
        if tags, ok := source["tags"].([]interface{}); ok {
            for _, tag := range tags {
                article.Tags = append(article.Tags, tag.(string))
            }
        }
        
        // 解析时间
        if createdAt, ok := source["created_at"].(string); ok {
            if t, err := time.Parse("2006-01-02T15:04:05.000Z", createdAt); err == nil {
                article.CreatedAt = t
            }
        }
        
        // 解析高亮
        if highlight, ok := hitMap["highlight"].(map[string]interface{}); ok {
            if contentHighlights, ok := highlight["content"].([]interface{}); ok {
                for _, h := range contentHighlights {
                    article.Highlight = append(article.Highlight, h.(string))
                }
            }
        }
        
        results = append(results, article)
    }
    
    return &es.SearchResponse{
        Total:   int64(totalValue),
        Results: results,
    }, nil
}
```

### 2. 高级搜索功能

```go
// service/advanced_search.go
package service

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "time"
    
    "server/global"
    "server/model/es"
)

// 高级搜索
func AdvancedSearch(params map[string]interface{}) (*es.SearchResponse, error) {
    var buf bytes.Buffer
    
    query := buildAdvancedQuery(params)
    
    if err := json.NewEncoder(&buf).Encode(query); err != nil {
        return nil, err
    }
    
    res, err := global.ES.Search(
        global.ES.Search.WithContext(context.Background()),
        global.ES.Search.WithIndex(es.ArticleIndex),
        global.ES.Search.WithBody(&buf),
        global.ES.Search.WithTrackTotalHits(true),
    )
    
    if err != nil {
        return nil, err
    }
    defer res.Body.Close()
    
    if res.IsError() {
        return nil, fmt.Errorf("Error searching: %s", res.String())
    }
    
    var result map[string]interface{}
    if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
        return nil, err
    }
    
    return parseAdvancedSearchResult(result)
}

// 构建高级查询
func buildAdvancedQuery(params map[string]interface{}) map[string]interface{} {
    must := []map[string]interface{}{
        {"term": map[string]interface{}{"status": "published"}},
    }
    
    should := []map[string]interface{}{}
    filter := []map[string]interface{}{}
    
    // 关键词搜索
    if keyword, ok := params["keyword"].(string); ok && keyword != "" {
        should = append(should, map[string]interface{}{
            "multi_match": map[string]interface{}{
                "query":  keyword,
                "fields": []string{"title^3", "content^2", "summary^1"},
                "type":   "best_fields",
            },
        })
    }
    
    // 标签过滤
    if tags, ok := params["tags"].([]string); ok && len(tags) > 0 {
        filter = append(filter, map[string]interface{}{
            "terms": map[string]interface{}{
                "tags": tags,
            },
        })
    }
    
    // 分类过滤
    if category, ok := params["category"].(string); ok && category != "" {
        filter = append(filter, map[string]interface{}{
            "term": map[string]interface{}{
                "category": category,
            },
        })
    }
    
    // 作者过滤
    if author, ok := params["author"].(string); ok && author != "" {
        filter = append(filter, map[string]interface{}{
            "term": map[string]interface{}{
                "author": author,
            },
        })
    }
    
    // 时间范围
    if startDate, ok := params["start_date"].(string); ok && startDate != "" {
        if endDate, ok := params["end_date"].(string); ok && endDate != "" {
            filter = append(filter, map[string]interface{}{
                "range": map[string]interface{}{
                    "created_at": map[string]interface{}{
                        "gte": startDate,
                        "lte": endDate,
                    },
                },
            })
        }
    }
    
    // 浏览量范围
    if minViews, ok := params["min_views"].(int); ok && minViews > 0 {
        filter = append(filter, map[string]interface{}{
            "range": map[string]interface{}{
                "view_count": map[string]interface{}{
                    "gte": minViews,
                },
            },
        })
    }
    
    boolQuery := map[string]interface{}{
        "must": must,
    }
    
    if len(should) > 0 {
        boolQuery["should"] = should
        boolQuery["minimum_should_match"] = 1
    }
    
    if len(filter) > 0 {
        boolQuery["filter"] = filter
    }
    
    return map[string]interface{}{
        "query": map[string]interface{}{
            "bool": boolQuery,
        },
        "highlight": map[string]interface{}{
            "fields": map[string]interface{}{
                "title": map[string]interface{}{
                    "pre_tags":  []string{"<em>"},
                    "post_tags": []string{"</em>"},
                },
                "content": map[string]interface{}{
                    "pre_tags":  []string{"<em>"},
                    "post_tags": []string{"</em>"},
                    "fragment_size": 150,
                    "number_of_fragments": 3,
                },
            },
        },
        "aggs": map[string]interface{}{
            "categories": map[string]interface{}{
                "terms": map[string]interface{}{
                    "field": "category",
                    "size":  10,
                },
            },
            "tags": map[string]interface{}{
                "terms": map[string]interface{}{
                    "field": "tags",
                    "size":  20,
                },
            },
            "date_histogram": map[string]interface{}{
                "date_histogram": map[string]interface{}{
                    "field":    "created_at",
                    "interval": "month",
                },
            },
        },
    }
}
```

### 3. 数据同步机制

```go
// service/sync_service.go
package service

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/elastic/go-elasticsearch/v8"
    "server/global"
    "server/model/database"
    "server/model/es"
)

// 同步文章到 ES
func SyncArticleToES(article *database.Article) error {
    esArticle := convertToESArticle(article)
    
    data, err := json.Marshal(esArticle)
    if err != nil {
        return err
    }
    
    res, err := global.ES.Index(
        es.ArticleIndex,
        bytes.NewReader(data),
        global.ES.Index.WithDocumentID(fmt.Sprintf("%d", article.ID)),
        global.ES.Index.WithContext(context.Background()),
    )
    
    if err != nil {
        return err
    }
    defer res.Body.Close()
    
    if res.IsError() {
        return fmt.Errorf("Error indexing document: %s", res.String())
    }
    
    return nil
}

// 批量同步文章
func BatchSyncArticlesToES(articles []database.Article) error {
    if len(articles) == 0 {
        return nil
    }
    
    var buf bytes.Buffer
    
    for _, article := range articles {
        // 添加索引操作
        buf.WriteString(fmt.Sprintf(`{"index":{"_id":"%d"}}`, article.ID))
        buf.WriteString("\n")
        
        // 添加文档数据
        esArticle := convertToESArticle(&article)
        data, err := json.Marshal(esArticle)
        if err != nil {
            return err
        }
        buf.Write(data)
        buf.WriteString("\n")
    }
    
    res, err := global.ES.Bulk(bytes.NewReader(buf.Bytes()), global.ES.Bulk.WithIndex(es.ArticleIndex))
    if err != nil {
        return err
    }
    defer res.Body.Close()
    
    if res.IsError() {
        return fmt.Errorf("Error bulk indexing: %s", res.String())
    }
    
    return nil
}

// 转换数据库模型到 ES 模型
func convertToESArticle(article *database.Article) *es.Article {
    // 获取标签
    var tags []string
    for _, tag := range article.Tags {
        tags = append(tags, tag.Name)
    }
    
    return &es.Article{
        ID:           article.ID,
        Title:        article.Title,
        Content:      article.Content,
        Summary:      article.Summary,
        Tags:         tags,
        Category:     article.Category.Name,
        Author:       article.User.Username,
        Status:       article.Status,
        ViewCount:    article.ViewCount,
        LikeCount:    article.LikeCount,
        CommentCount: article.CommentCount,
        CreatedAt:    article.CreatedAt,
        UpdatedAt:    article.UpdatedAt,
    }
}

// 从 ES 删除文章
func DeleteArticleFromES(articleID uint) error {
    res, err := global.ES.Delete(
        es.ArticleIndex,
        fmt.Sprintf("%d", articleID),
    )
    
    if err != nil {
        return err
    }
    defer res.Body.Close()
    
    if res.IsError() && res.StatusCode != 404 {
        return fmt.Errorf("Error deleting document: %s", res.String())
    }
    
    return nil
}
```

## API 接口实现

### 1. 搜索接口

```go
// api/article.go
func SearchArticles(c *gin.Context) {
    var req request.SearchRequest
    if err := c.ShouldBindQuery(&req); err != nil {
        response.FailWithMessage("参数错误", c)
        return
    }
    
    // 构建过滤条件
    filters := make(map[string]interface{})
    if req.Category != "" {
        filters["category"] = req.Category
    }
    if len(req.Tags) > 0 {
        filters["tags"] = req.Tags
    }
    if req.StartDate != "" && req.EndDate != "" {
        filters["date_range"] = map[string]interface{}{
            "gte": req.StartDate,
            "lte": req.EndDate,
        }
    }
    
    // 执行搜索
    result, err := articleService.SearchArticles(req.Keyword, req.Page, req.PageSize, filters)
    if err != nil {
        response.FailWithMessage("搜索失败: "+err.Error(), c)
        return
    }
    
    response.OkWithData(result, c)
}

// 高级搜索接口
func AdvancedSearch(c *gin.Context) {
    var req request.AdvancedSearchRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.FailWithMessage("参数错误", c)
        return
    }
    
    // 转换请求参数
    params := make(map[string]interface{})
    if req.Keyword != "" {
        params["keyword"] = req.Keyword
    }
    if len(req.Tags) > 0 {
        params["tags"] = req.Tags
    }
    if req.Category != "" {
        params["category"] = req.Category
    }
    if req.Author != "" {
        params["author"] = req.Author
    }
    if req.StartDate != "" {
        params["start_date"] = req.StartDate
    }
    if req.EndDate != "" {
        params["end_date"] = req.EndDate
    }
    if req.MinViews > 0 {
        params["min_views"] = req.MinViews
    }
    
    result, err := articleService.AdvancedSearch(params)
    if err != nil {
        response.FailWithMessage("搜索失败: "+err.Error(), c)
        return
    }
    
    response.OkWithData(result, c)
}
```

### 2. 搜索建议接口

```go
// api/suggest.go
func GetSearchSuggestions(c *gin.Context) {
    keyword := c.Query("q")
    if keyword == "" {
        response.OkWithData([]string{}, c)
        return
    }
    
    suggestions, err := articleService.GetSearchSuggestions(keyword)
    if err != nil {
        response.FailWithMessage("获取建议失败", c)
        return
    }
    
    response.OkWithData(suggestions, c)
}

// 搜索建议实现
func GetSearchSuggestions(keyword string) ([]string, error) {
    query := map[string]interface{}{
        "suggest": map[string]interface{}{
            "title_suggest": map[string]interface{}{
                "prefix": keyword,
                "completion": map[string]interface{}{
                    "field": "title_suggest",
                    "size":  5,
                },
            },
        },
    }
    
    var buf bytes.Buffer
    if err := json.NewEncoder(&buf).Encode(query); err != nil {
        return nil, err
    }
    
    res, err := global.ES.Search(
        global.ES.Search.WithIndex(es.ArticleIndex),
        global.ES.Search.WithBody(&buf),
    )
    
    if err != nil {
        return nil, err
    }
    defer res.Body.Close()
    
    var result map[string]interface{}
    if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
        return nil, err
    }
    
    var suggestions []string
    if suggest, ok := result["suggest"].(map[string]interface{}); ok {
        if titleSuggest, ok := suggest["title_suggest"].([]interface{}); ok {
            for _, item := range titleSuggest {
                if itemMap, ok := item.(map[string]interface{}); ok {
                    if options, ok := itemMap["options"].([]interface{}); ok {
                        for _, option := range options {
                            if optionMap, ok := option.(map[string]interface{}); ok {
                                if text, ok := optionMap["text"].(string); ok {
                                    suggestions = append(suggestions, text)
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    return suggestions, nil
}
```

## 前端集成

### 1. API 接口封装

```typescript
// api/search.ts
import request from '@/utils/request'

export interface SearchParams {
  keyword?: string
  page?: number
  pageSize?: number
  category?: string
  tags?: string[]
  startDate?: string
  endDate?: string
}

export interface SearchResponse {
  total: number
  results: ArticleSearchResult[]
  aggs?: any
}

// 搜索文章
export const searchArticles = (params: SearchParams): Promise<SearchResponse> => {
  return request.get('/articles/search', { params })
}

// 高级搜索
export const advancedSearch = (params: any): Promise<SearchResponse> => {
  return request.post('/articles/advanced-search', params)
}

// 获取搜索建议
export const getSearchSuggestions = (keyword: string): Promise<string[]> => {
  return request.get('/articles/suggestions', { params: { q: keyword } })
}
```

### 2. 搜索状态管理

```typescript
// stores/search.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { searchArticles, type SearchParams } from '@/api/search'

export const useSearchStore = defineStore('search', () => {
  const results = ref([])
  const total = ref(0)
  const loading = ref(false)
  const keyword = ref('')
  
  const hasResults = computed(() => results.value.length > 0)
  
  const performSearch = async (params: SearchParams) => {
    loading.value = true
    try {
      const response = await searchArticles(params)
      results.value = response.results
      total.value = response.total
      keyword.value = params.keyword || ''
    } catch (error) {
      console.error('搜索失败:', error)
      throw error
    } finally {
      loading.value = false
    }
  }
  
  const clearResults = () => {
    results.value = []
    total.value = 0
    keyword.value = ''
  }
  
  return {
    results,
    total,
    loading,
    keyword,
    hasResults,
    performSearch,
    clearResults,
  }
})
```

## 性能优化

### 1. 索引优化

```go
// 优化索引设置
func OptimizeIndex() error {
    settings := `{
        "settings": {
            "number_of_shards": 1,
            "number_of_replicas": 0,
            "refresh_interval": "30s",
            "index": {
                "max_result_window": 10000
            }
        }
    }`
    
    res, err := global.ES.Indices.PutSettings(
        strings.NewReader(settings),
        global.ES.Indices.PutSettings.WithIndex(es.ArticleIndex),
    )
    
    if err != nil {
        return err
    }
    defer res.Body.Close()
    
    return nil
}
```

### 2. 缓存机制

```go
// 搜索缓存
func SearchWithCache(query string, page, pageSize int, filters map[string]interface{}) (*es.SearchResponse, error) {
    // 生成缓存键
    cacheKey := generateCacheKey(query, page, pageSize, filters)
    
    // 尝试从缓存获取
    if cached, err := global.REDIS.Get(context.Background(), cacheKey).Result(); err == nil {
        var result es.SearchResponse
        if err := json.Unmarshal([]byte(cached), &result); err == nil {
            return &result, nil
        }
    }
    
    // 执行搜索
    result, err := SearchArticles(query, page, pageSize, filters)
    if err != nil {
        return nil, err
    }
    
    // 缓存结果
    if data, err := json.Marshal(result); err == nil {
        global.REDIS.Set(context.Background(), cacheKey, data, 5*time.Minute)
    }
    
    return result, nil
}

func generateCacheKey(query string, page, pageSize int, filters map[string]interface{}) string {
    data := map[string]interface{}{
        "query":     query,
        "page":      page,
        "pageSize":  pageSize,
        "filters":   filters,
    }
    
    jsonData, _ := json.Marshal(data)
    return "search:" + fmt.Sprintf("%x", md5.Sum(jsonData))
}
```

## 总结

Elasticsearch 为博客系统提供了强大的全文搜索能力，通过合理的索引设计和查询优化，可以显著提升搜索性能和用户体验。

**关键要点：**
- 理解 Elasticsearch 的基本概念和优势
- 正确设计索引映射和分词器配置
- 实现高效的搜索查询和结果处理
- 建立数据同步机制保持一致性
- 优化搜索性能和用户体验

**最佳实践：**
1. **索引设计**: 合理设计字段映射和分词器
2. **查询优化**: 使用合适的查询类型和过滤条件
3. **数据同步**: 建立可靠的数据同步机制，保持 ES 与数据库的一致性
4. **性能优化**: 合理配置索引和查询，提升搜索性能
5. **用户体验**: 提供搜索建议、高亮显示等增强功能

## 常见问题和解决方案

### 1. 数据同步问题

**问题**: ES 中的数据与数据库不一致

**解决方案**:
```go
// 定时同步任务
func StartSyncTask() {
    ticker := time.NewTicker(5 * time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        if err := SyncAllArticles(); err != nil {
            log.Printf("同步失败: %v", err)
        }
    }
}

// 全量同步
func SyncAllArticles() error {
    var articles []database.Article
    if err := global.DB.Preload("User").Preload("Category").Preload("Tags").Find(&articles).Error; err != nil {
        return err
    }
    
    return BatchSyncArticlesToES(articles)
}
```

### 2. 搜索性能问题

**问题**: 搜索响应慢，用户体验差

**解决方案**:
```go
// 查询优化
func OptimizeSearchQuery(query string) map[string]interface{} {
    return map[string]interface{}{
        "query": map[string]interface{}{
            "bool": map[string]interface{}{
                "must": []map[string]interface{}{
                    {"term": map[string]interface{}{"status": "published"}},
                    {"multi_match": map[string]interface{}{
                        "query":  query,
                        "fields": []string{"title^3", "content^2", "summary^1"},
                        "type":   "best_fields",
                        "operator": "and", // 使用 AND 操作符提高精确度
                    }},
                },
                "filter": []map[string]interface{}{
                    {"range": map[string]interface{}{
                        "created_at": map[string]interface{}{
                            "gte": "now-1y", // 只搜索最近一年的文章
                        },
                    }},
                },
            },
        },
        "size": 20, // 限制返回结果数量
    }
}
```

### 3. 中文分词问题

**问题**: 中文搜索效果不佳

**解决方案**:
```go
// 配置 IK 分词器
const IKMapping = `{
    "settings": {
        "analysis": {
            "analyzer": {
                "ik_max_word": {
                    "type": "ik_max_word",
                    "use_smart": false
                },
                "ik_smart": {
                    "type": "ik_smart",
                    "use_smart": true
                }
            }
        }
    }
}`
```

## 监控和维护

### 1. 搜索性能监控

```go
// 搜索性能监控
func MonitorSearchPerformance() {
    ticker := time.NewTicker(1 * time.Hour)
    defer ticker.Stop()
    
    for range ticker.C {
        stats, err := GetClusterStats()
        if err != nil {
            log.Printf("获取集群状态失败: %v", err)
            continue
        }
        
        // 监控索引大小
        if stats.Indices.Size > 10*1024*1024*1024 { // 10GB
            log.Printf("警告: 索引大小超过 10GB")
        }
        
        // 监控查询延迟
        if stats.Indices.Search.QueryTime > 1000 { // 1秒
            log.Printf("警告: 查询延迟过高: %dms", stats.Indices.Search.QueryTime)
        }
    }
}
```

### 2. 索引维护

```go
// 索引优化
func OptimizeIndex() error {
    res, err := global.ES.Indices.Forcemerge(
        []string{es.ArticleIndex},
        global.ES.Indices.Forcemerge.WithMaxNumSegments(1),
    )
    
    if err != nil {
        return err
    }
    defer res.Body.Close()
    
    return nil
}

// 清理过期数据
func CleanupOldData() error {
    query := map[string]interface{}{
        "query": map[string]interface{}{
            "range": map[string]interface{}{
                "created_at": map[string]interface{}{
                    "lt": "now-2y", // 删除2年前的文章
                },
            },
        },
    }
    
    var buf bytes.Buffer
    if err := json.NewEncoder(&buf).Encode(query); err != nil {
        return err
    }
    
    res, err := global.ES.DeleteByQuery(
        []string{es.ArticleIndex},
        bytes.NewReader(buf.Bytes()),
    )
    
    if err != nil {
        return err
    }
    defer res.Body.Close()
    
    return nil
}
```

## 生产环境部署

### 1. Docker 部署

```yaml
# docker-compose.yml
version: '3.8'
services:
  elasticsearch:
    image: elasticsearch:8.15.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
    volumes:
      - es_data:/usr/share/elasticsearch/data
    networks:
      - blog_network

  kibana:
    image: kibana:8.15.0
    container_name: kibana
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch
    networks:
      - blog_network

volumes:
  es_data:

networks:
  blog_network:
    driver: bridge
```

### 2. 配置文件

```yaml
# config/elasticsearch.yaml
elasticsearch:
  address: "http://localhost:9200"
  username: ""
  password: ""
  index:
    name: "articles"
    shards: 1
    replicas: 0
  sync:
    enabled: true
    interval: "5m"
    batch_size: 100
  search:
    cache_enabled: true
    cache_ttl: "5m"
    max_results: 1000
```

## 总结

Elasticsearch 为博客系统提供了强大的全文搜索能力，通过合理的索引设计和查询优化，可以显著提升搜索性能和用户体验。

**关键要点：**
- 理解 Elasticsearch 的基本概念和优势
- 正确设计索引映射和分词器配置
- 实现高效的搜索查询和结果处理
- 建立数据同步机制保持一致性
- 优化搜索性能和用户体验

**最佳实践：**
1. **索引设计**: 合理设计字段映射和分词器
2. **查询优化**: 使用合适的查询类型和过滤条件
3. **数据同步**: 建立可靠的数据同步机制，保持 ES 与数据库的一致性
4. **性能优化**: 合理配置索引和查询，提升搜索性能
5. **用户体验**: 提供搜索建议、高亮显示等增强功能
6. **监控维护**: 定期监控搜索性能，及时优化索引
7. **安全配置**: 在生产环境中启用安全认证

通过合理的 Elasticsearch 配置和使用，可以为博客系统提供高效、准确的搜索功能，大大提升用户体验。

---

*本文详细介绍了 Elasticsearch 搜索功能的实现原理、配置方法和最佳实践，希望对您的开发工作有所帮助。*