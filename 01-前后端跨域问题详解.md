# 前后端跨域问题详解 - 从原理到实践

## 问题背景

在开发博客项目时，前端运行在 `localhost:3000`，后端运行在 `localhost:8080`，浏览器阻止了跨域请求，导致前端无法正常调用后端 API。

## 什么是跨域？

### 同源策略 (Same-Origin Policy)

同源策略是浏览器的一个重要的安全机制，它限制了从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。

**同源的定义：**
- 协议相同 (http/https)
- 域名相同
- 端口相同

**示例：**
```
http://localhost:3000 和 http://localhost:8080 不同源
https://example.com 和 http://example.com 不同源
http://api.example.com 和 http://www.example.com 不同源
```

### 跨域请求的类型

1. **简单请求 (Simple Requests)**
   - GET、HEAD、POST 方法
   - 只允许特定的 Content-Type
   - 没有自定义头部

2. **预检请求 (Preflight Requests)**
   - 非简单请求会先发送 OPTIONS 请求
   - 服务器需要响应预检请求
   - 预检通过后才能发送实际请求

## 解决方案详解

### 1. 后端 CORS 配置

在 Gin 框架中配置 CORS 中间件：

```go
// middleware/cors.go
package middleware

import (
    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "time"
)

func Cors() gin.HandlerFunc {
    return cors.New(cors.Config{
        // 允许的源
        AllowOrigins: []string{
            "http://localhost:3000",     // 开发环境
            "https://yourdomain.com",    // 生产环境
        },
        
        // 允许的 HTTP 方法
        AllowMethods: []string{
            "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH",
        },
        
        // 允许的请求头
        AllowHeaders: []string{
            "Origin", "Content-Type", "Accept", "Authorization",
            "X-Requested-With", "Cache-Control", "X-CSRF-Token",
        },
        
        // 暴露的响应头
        ExposeHeaders: []string{
            "Content-Length", "Content-Type", "X-Total-Count",
        },
        
        // 是否允许携带凭证
        AllowCredentials: true,
        
        // 预检请求的缓存时间
        MaxAge: 12 * time.Hour,
    })
}
```

### 2. 在路由中使用中间件

```go
// initialize/router.go
func InitRouter() {
    r := gin.Default()
    
    // 全局使用 CORS 中间件
    r.Use(middleware.Cors())
    
    // 或者只在特定路由组使用
    api := r.Group("/api")
    api.Use(middleware.Cors())
    {
        api.GET("/articles", api.GetArticles)
        api.POST("/articles", api.CreateArticle)
        // ... 其他路由
    }
    
    r.Run(":8080")
}
```

### 3. 前端代理配置 (开发环境)

在 Vite 中配置代理：

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '/api')
      }
    }
  }
})
```

## 深入理解 CORS

### CORS 响应头详解

1. **Access-Control-Allow-Origin**
   ```
   Access-Control-Allow-Origin: http://localhost:3000
   Access-Control-Allow-Origin: *  // 允许所有源（不推荐生产环境）
   ```

2. **Access-Control-Allow-Methods**
   ```
   Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
   ```

3. **Access-Control-Allow-Headers**
   ```
   Access-Control-Allow-Headers: Content-Type, Authorization
   ```

4. **Access-Control-Allow-Credentials**
   ```
   Access-Control-Allow-Credentials: true
   ```

5. **Access-Control-Max-Age**
   ```
   Access-Control-Max-Age: 86400  // 预检请求缓存时间（秒）
   ```

### 预检请求流程

```
1. 浏览器发送 OPTIONS 请求
   OPTIONS /api/articles HTTP/1.1
   Origin: http://localhost:3000
   Access-Control-Request-Method: POST
   Access-Control-Request-Headers: Content-Type, Authorization

2. 服务器响应预检请求
   HTTP/1.1 200 OK
   Access-Control-Allow-Origin: http://localhost:3000
   Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
   Access-Control-Allow-Headers: Content-Type, Authorization
   Access-Control-Max-Age: 86400

3. 浏览器发送实际请求
   POST /api/articles HTTP/1.1
   Origin: http://localhost:3000
   Content-Type: application/json
   Authorization: Bearer token

4. 服务器响应实际请求
   HTTP/1.1 200 OK
   Access-Control-Allow-Origin: http://localhost:3000
   Content-Type: application/json
   { "success": true, "data": {...} }
```

## 常见问题和解决方案

### 1. 携带凭证的跨域请求

当 `AllowCredentials: true` 时，`AllowOrigins` 不能设置为 `*`：

```go
// ❌ 错误配置
AllowOrigins: []string{"*"},
AllowCredentials: true,

// ✅ 正确配置
AllowOrigins: []string{"http://localhost:3000"},
AllowCredentials: true,
```

### 2. 自定义请求头

如果需要发送自定义请求头，需要在 `AllowHeaders` 中添加：

```go
AllowHeaders: []string{
    "Origin", "Content-Type", "Accept", "Authorization",
    "X-Custom-Header", "X-API-Key",  // 添加自定义头部
},
```

### 3. 处理复杂请求

对于 PUT、DELETE 等复杂请求，确保服务器正确处理 OPTIONS 请求：

```go
func HandleOptions(c *gin.Context) {
    c.Header("Access-Control-Allow-Origin", "*")
    c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
    c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")
    c.Status(200)
}

// 在路由中注册
r.OPTIONS("/*path", HandleOptions)
```

## 生产环境最佳实践

### 1. 安全配置

```go
func Cors() gin.HandlerFunc {
    return cors.New(cors.Config{
        // 只允许特定域名
        AllowOrigins: []string{
            "https://yourdomain.com",
            "https://www.yourdomain.com",
        },
        
        // 限制允许的方法
        AllowMethods: []string{"GET", "POST", "PUT", "DELETE"},
        
        // 限制允许的头部
        AllowHeaders: []string{
            "Content-Type", "Authorization", "X-Requested-With",
        },
        
        // 不暴露敏感头部
        ExposeHeaders: []string{"Content-Length"},
        
        AllowCredentials: true,
        MaxAge: 12 * time.Hour,
    })
}
```

### 2. 环境变量配置

```go
// config/cors.go
type CorsConfig struct {
    AllowOrigins []string `mapstructure:"allow_origins"`
    AllowMethods []string `mapstructure:"allow_methods"`
    AllowHeaders []string `mapstructure:"allow_headers"`
}

// config.yaml
cors:
  allow_origins:
    - "http://localhost:3000"
    - "https://yourdomain.com"
  allow_methods:
    - "GET"
    - "POST"
    - "PUT"
    - "DELETE"
  allow_headers:
    - "Content-Type"
    - "Authorization"
```

### 3. 动态 CORS 配置

```go
func DynamicCors() gin.HandlerFunc {
    return func(c *gin.Context) {
        origin := c.Request.Header.Get("Origin")
        
        // 检查是否在允许的域名列表中
        allowedOrigins := []string{
            "http://localhost:3000",
            "https://yourdomain.com",
        }
        
        for _, allowed := range allowedOrigins {
            if origin == allowed {
                c.Header("Access-Control-Allow-Origin", origin)
                break
            }
        }
        
        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")
        c.Header("Access-Control-Allow-Credentials", "true")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}
```

## 调试技巧

### 1. 浏览器开发者工具

- 打开 Network 面板
- 查看 OPTIONS 请求和实际请求
- 检查响应头中的 CORS 相关字段

### 2. 服务器日志

```go
func CorsWithLogging() gin.HandlerFunc {
    return func(c *gin.Context) {
        origin := c.Request.Header.Get("Origin")
        method := c.Request.Method
        
        log.Printf("CORS Request: %s %s from %s", method, c.Request.URL.Path, origin)
        
        // CORS 处理逻辑...
        
        c.Next()
    }
}
```

### 3. 常见错误排查

1. **CORS 错误：No 'Access-Control-Allow-Origin' header**
   - 检查服务器是否正确设置了 CORS 头
   - 确认中间件顺序正确

2. **预检请求失败**
   - 确保服务器正确处理 OPTIONS 请求
   - 检查 `AllowMethods` 和 `AllowHeaders` 配置

3. **凭证问题**
   - 确认 `AllowCredentials: true`
   - 检查 `AllowOrigins` 不能为 `*`

## 总结

CORS 是现代 Web 开发中必须面对的问题，理解其原理和正确配置对于前后端分离项目至关重要。通过合理的 CORS 配置，可以确保应用的安全性和可用性。

**关键要点：**
- 理解同源策略和跨域概念
- 正确配置 CORS 中间件
- 区分简单请求和预检请求
- 生产环境的安全考虑
- 掌握调试和排查技巧

---

*本文详细介绍了前后端跨域问题的原理、解决方案和最佳实践，希望对您的开发工作有所帮助。*
