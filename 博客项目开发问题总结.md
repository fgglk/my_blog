# 博客项目开发问题总结 - 读书笔记

## 项目概述

本项目是一个基于 **Vue 3 + Go** 的全栈博客系统，采用前后端分离架构。前端使用 Vue 3 + TypeScript + Element Plus，后端使用 Go + Gin + GORM + MySQL + Redis + Elasticsearch。

## 技术栈

### 前端技术栈
- **Vue 3** - 渐进式 JavaScript 框架
- **TypeScript** - 类型安全的 JavaScript 超集
- **Vite** - 现代前端构建工具
- **Pinia** - Vue 3 状态管理
- **Vue Router** - 路由管理
- **Element Plus** - UI 组件库
- **Axios** - HTTP 客户端
- **Sass** - CSS 预处理器

### 后端技术栈
- **Go 1.23** - 后端编程语言
- **Gin** - Web 框架
- **GORM** - ORM 框架
- **MySQL** - 关系型数据库
- **Redis** - 缓存数据库
- **Elasticsearch** - 搜索引擎
- **JWT** - 身份认证
- **Zap** - 日志框架

## 开发过程中遇到的问题及解决方案

### 1. 前后端跨域问题 (CORS)

**问题描述：**
前端运行在 `localhost:3000`，后端运行在 `localhost:8080`，浏览器阻止跨域请求。

**解决方案：**
在后端 Gin 框架中配置 CORS 中间件：

```go
// middleware/cors.go
func Cors() gin.HandlerFunc {
    return cors.New(cors.Config{
        AllowOrigins:     []string{"http://localhost:3000"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    })
}
```

**学习要点：**
- 理解浏览器的同源策略
- CORS 预检请求机制
- 生产环境需要配置正确的域名

### 2. JWT Token 认证问题

**问题描述：**
用户登录后，后续请求需要携带 JWT token，但前端存储和传递 token 的方式不当。

**解决方案：**
1. 前端使用 localStorage 存储 token
2. 在 Axios 拦截器中自动添加 Authorization 头
3. 后端验证 token 有效性

```typescript
// utils/request.ts
const request = axios.create({
    baseURL: '/api',
    timeout: 10000
})

// 请求拦截器
request.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('token')
        if (token) {
            config.headers.Authorization = `Bearer ${token}`
        }
        return config
    }
)
```

**学习要点：**
- JWT 的组成结构（Header.Payload.Signature）
- Token 的安全存储方式
- 请求拦截器的使用

### 3. 数据库连接池配置

**问题描述：**
高并发场景下数据库连接数不足，导致请求超时。

**解决方案：**
配置 MySQL 连接池参数：

```go
// initialize/mysql.go
func InitMysql() {
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        global.CONFIG.Mysql.Username,
        global.CONFIG.Mysql.Password,
        global.CONFIG.Mysql.Host,
        global.CONFIG.Mysql.Port,
        global.CONFIG.Mysql.Database,
    )
    
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        panic("连接数据库失败")
    }
    
    sqlDB, _ := db.DB()
    sqlDB.SetMaxIdleConns(10)  // 最大空闲连接数
    sqlDB.SetMaxOpenConns(100) // 最大打开连接数
    sqlDB.SetConnMaxLifetime(time.Hour) // 连接最大生命周期
    
    global.DB = db
}
```

**学习要点：**
- 连接池的作用和重要性
- 合理配置连接池参数
- 数据库性能优化

### 4. Elasticsearch 搜索功能实现

**问题描述：**
需要实现文章的全文搜索功能，包括标题、内容、标签的模糊匹配。

**解决方案：**
1. 创建 ES 索引映射
2. 实现文章同步到 ES
3. 实现搜索 API

```go
// service/es_index.go
func CreateArticleIndex() error {
    mapping := `{
        "mappings": {
            "properties": {
                "title": {"type": "text", "analyzer": "ik_max_word"},
                "content": {"type": "text", "analyzer": "ik_max_word"},
                "tags": {"type": "keyword"},
                "category": {"type": "keyword"},
                "created_at": {"type": "date"}
            }
        }
    }`
    
    _, err := global.ES.Indices.Create(
        "articles",
        global.ES.Indices.Create.WithBody(strings.NewReader(mapping)),
    )
    return err
}
```

**学习要点：**
- ES 索引和映射概念
- 中文分词器配置
- 搜索查询 DSL

### 5. 文件上传功能

**问题描述：**
需要支持图片上传功能，包括文件类型验证、大小限制、存储路径管理。

**解决方案：**
1. 前端使用 FormData 上传
2. 后端验证文件类型和大小
3. 生成唯一文件名存储

```go
// api/image.go
func UploadImage(c *gin.Context) {
    file, err := c.FormFile("file")
    if err != nil {
        response.FailWithMessage("文件上传失败", c)
        return
    }
    
    // 验证文件类型
    if !isValidImageType(file.Header.Get("Content-Type")) {
        response.FailWithMessage("不支持的文件类型", c)
        return
    }
    
    // 验证文件大小
    if file.Size > 5*1024*1024 { // 5MB
        response.FailWithMessage("文件大小超过限制", c)
        return
    }
    
    // 生成唯一文件名
    ext := filepath.Ext(file.Filename)
    filename := uuid.New().String() + ext
    
    // 保存文件
    dst := fmt.Sprintf("./uploads/%s", filename)
    if err := c.SaveUploadedFile(file, dst); err != nil {
        response.FailWithMessage("文件保存失败", c)
        return
    }
    
    response.OkWithData(gin.H{"url": "/uploads/" + filename}, c)
}
```

**学习要点：**
- 文件上传的安全考虑
- 文件类型验证的重要性
- 静态文件服务配置

### 6. 前端路由权限控制

**问题描述：**
需要根据用户登录状态控制页面访问权限，未登录用户只能访问公开页面。

**解决方案：**
使用 Vue Router 的导航守卫：

```typescript
// router/index.ts
router.beforeEach((to, from, next) => {
    const token = localStorage.getItem('token')
    const requiresAuth = to.meta.requiresAuth
    
    if (requiresAuth && !token) {
        next('/login')
    } else if (to.path === '/login' && token) {
        next('/')
    } else {
        next()
    }
})
```

**学习要点：**
- 路由元信息的使用
- 导航守卫的执行顺序
- 权限控制的最佳实践

### 7. 状态管理设计

**问题描述：**
用户信息、文章数据等需要在多个组件间共享，避免重复请求。

**解决方案：**
使用 Pinia 进行状态管理：

```typescript
// stores/user.ts
export const useUserStore = defineStore('user', {
    state: () => ({
        userInfo: null as UserInfo | null,
        token: localStorage.getItem('token') || ''
    }),
    
    actions: {
        setUserInfo(userInfo: UserInfo) {
            this.userInfo = userInfo
        },
        
        setToken(token: string) {
            this.token = token
            localStorage.setItem('token', token)
        },
        
        logout() {
            this.userInfo = null
            this.token = ''
            localStorage.removeItem('token')
        }
    }
})
```

**学习要点：**
- 状态管理的重要性
- Pinia 的基本用法
- 持久化存储策略

### 8. 评论系统实现

**问题描述：**
需要实现文章的评论功能，支持嵌套评论和分页。

**解决方案：**
1. 设计评论数据表结构
2. 实现评论的增删查改
3. 前端递归渲染评论树

```go
// model/database/comment.go
type Comment struct {
    BaseModel
    Content    string    `json:"content" gorm:"type:text;not null"`
    UserID     uint      `json:"user_id" gorm:"not null"`
    ArticleID  uint      `json:"article_id" gorm:"not null"`
    ParentID   *uint     `json:"parent_id" gorm:"default:null"`
    User       User      `json:"user" gorm:"foreignKey:UserID"`
    Children   []Comment `json:"children" gorm:"foreignKey:ParentID"`
}
```

**学习要点：**
- 树形结构的数据库设计
- 递归查询的实现
- 前端递归组件的编写

### 9. 性能优化

**问题描述：**
文章列表页面加载缓慢，需要优化查询性能。

**解决方案：**
1. 使用 Redis 缓存热门文章
2. 数据库查询优化（索引、分页）
3. 前端虚拟滚动

```go
// service/article.go
func GetArticleList(page, pageSize int) ([]Article, int64, error) {
    var articles []Article
    var total int64
    
    // 使用 Redis 缓存
    cacheKey := fmt.Sprintf("articles:page:%d:size:%d", page, pageSize)
    if cached, err := global.REDIS.Get(context.Background(), cacheKey).Result(); err == nil {
        json.Unmarshal([]byte(cached), &articles)
        return articles, total, nil
    }
    
    // 数据库查询
    offset := (page - 1) * pageSize
    err := global.DB.Preload("User").Preload("Category").Preload("Tags").
        Offset(offset).Limit(pageSize).Order("created_at desc").Find(&articles).Error
    
    if err == nil {
        // 缓存结果
        if data, err := json.Marshal(articles); err == nil {
            global.REDIS.Set(context.Background(), cacheKey, data, time.Hour)
        }
    }
    
    return articles, total, err
}
```

**学习要点：**
- 缓存策略的选择
- 数据库查询优化技巧
- 前端性能优化方法

### 10. 部署和运维

**问题描述：**
项目开发完成后，需要部署到生产环境，包括服务器配置、域名解析、SSL 证书等。

**解决方案：**
1. 使用 Docker 容器化部署
2. 配置 Nginx 反向代理
3. 使用 Let's Encrypt 免费 SSL 证书

```nginx
# Nginx 配置示例
server {
    listen 80;
    server_name your-domain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl;
    server_name your-domain.com;
    
    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;
    
    location / {
        root /var/www/html;
        try_files $uri $uri/ /index.html;
    }
    
    location /api {
        proxy_pass http://localhost:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

**学习要点：**
- Docker 容器化技术
- Nginx 配置和优化
- SSL 证书申请和配置
- 服务器安全配置

## 项目收获

### 技术能力提升
1. **全栈开发能力**：从前端到后端，从数据库到部署，掌握了完整的开发流程
2. **架构设计能力**：学会了如何设计可扩展的系统架构
3. **问题解决能力**：遇到问题时能够快速定位和解决

### 最佳实践总结
1. **代码规范**：统一的代码风格和命名规范
2. **错误处理**：完善的错误处理和日志记录
3. **安全考虑**：输入验证、SQL 注入防护、XSS 防护等
4. **性能优化**：缓存策略、数据库优化、前端优化

### 未来改进方向
1. **微服务架构**：将单体应用拆分为微服务
2. **消息队列**：引入 Redis 或 RabbitMQ 处理异步任务
3. **监控系统**：集成 Prometheus + Grafana 监控系统
4. **CI/CD**：自动化部署流程
5. **容器编排**：使用 Kubernetes 管理容器

## 总结

通过这个博客项目的开发，不仅掌握了 Vue 3 + Go 的技术栈，更重要的是学会了如何解决实际开发中遇到的各种问题。从需求分析到系统设计，从编码实现到测试部署，每个环节都充满了挑战和学习机会。

这个项目虽然功能相对简单，但涵盖了现代 Web 开发的主要技术点，是一个很好的全栈开发实践项目。通过解决这些问题，对前后端分离架构、数据库设计、性能优化、安全防护等方面都有了更深入的理解。

---

*本文档记录了博客项目开发过程中的主要问题和解决方案，可作为后续项目的参考和学习资料。*
