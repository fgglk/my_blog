# 前端路由权限控制详解 - 安全可靠的路由管理

## 问题背景

在博客项目中，需要实现前端路由权限控制，确保用户只能访问有权限的页面。包括登录状态验证、角色权限控制、动态路由生成等功能。

## 路由权限控制的核心问题

### 1. 权限验证问题
- 登录状态检查
- 用户角色验证
- 页面权限控制
- 动态权限更新

### 2. 路由管理问题
- 静态路由 vs 动态路由
- 路由懒加载
- 路由缓存
- 404 页面处理

### 3. 用户体验问题
- 权限不足提示
- 登录跳转
- 页面加载状态
- 权限变更响应

## 路由配置设计

### 1. 路由元信息定义

```typescript
// types/router.ts
export interface RouteMeta {
  title?: string
  requiresAuth?: boolean
  roles?: string[]
  permissions?: string[]
  keepAlive?: boolean
  hidden?: boolean
  icon?: string
  breadcrumb?: boolean
}

export interface AppRouteRecordRaw {
  path: string
  name: string
  component?: any
  redirect?: string
  meta?: RouteMeta
  children?: AppRouteRecordRaw[]
}
```

### 2. 路由配置

```typescript
// router/routes.ts
import { AppRouteRecordRaw } from '@/types/router'

// 公共路由
export const constantRoutes: AppRouteRecordRaw[] = [
  {
    path: '/',
    name: 'Home',
    component: () => import('@/views/Home.vue'),
    meta: {
      title: '首页',
      keepAlive: true,
    },
  },
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/Login.vue'),
    meta: {
      title: '登录',
      hidden: true,
    },
  },
  {
    path: '/register',
    name: 'Register',
    component: () => import('@/views/Register.vue'),
    meta: {
      title: '注册',
      hidden: true,
    },
  },
  {
    path: '/articles',
    name: 'Articles',
    component: () => import('@/views/Articles.vue'),
    meta: {
      title: '文章列表',
      keepAlive: true,
    },
  },
  {
    path: '/article/:id',
    name: 'ArticleDetail',
    component: () => import('@/views/ArticleDetail.vue'),
    meta: {
      title: '文章详情',
      keepAlive: false,
    },
  },
]

// 需要权限的路由
export const asyncRoutes: AppRouteRecordRaw[] = [
  {
    path: '/write',
    name: 'Write',
    component: () => import('@/views/Write.vue'),
    meta: {
      title: '写文章',
      requiresAuth: true,
      roles: ['user', 'admin'],
      permissions: ['article:write'],
    },
  },
  {
    path: '/profile',
    name: 'Profile',
    component: () => import('@/views/Profile.vue'),
    meta: {
      title: '个人中心',
      requiresAuth: true,
      roles: ['user', 'admin'],
    },
  },
  {
    path: '/favorites',
    name: 'Favorites',
    component: () => import('@/views/Favorites.vue'),
    meta: {
      title: '我的收藏',
      requiresAuth: true,
      roles: ['user', 'admin'],
    },
  },
  {
    path: '/admin',
    name: 'Admin',
    component: () => import('@/views/admin/Layout.vue'),
    meta: {
      title: '管理后台',
      requiresAuth: true,
      roles: ['admin'],
      permissions: ['admin:access'],
    },
    children: [
      {
        path: 'articles',
        name: 'AdminArticles',
        component: () => import('@/views/admin/Articles.vue'),
        meta: {
          title: '文章管理',
          roles: ['admin'],
          permissions: ['article:manage'],
        },
      },
      {
        path: 'users',
        name: 'AdminUsers',
        component: () => import('@/views/admin/Users.vue'),
        meta: {
          title: '用户管理',
          roles: ['admin'],
          permissions: ['user:manage'],
        },
      },
      {
        path: 'comments',
        name: 'AdminComments',
        component: () => import('@/views/admin/Comments.vue'),
        meta: {
          title: '评论管理',
          roles: ['admin'],
          permissions: ['comment:manage'],
        },
      },
    ],
  },
]
```

## 权限验证逻辑

### 1. 权限验证工具

```typescript
// utils/permission.ts
import { useUserStore } from '@/stores/user'

export interface UserInfo {
  id: number
  username: string
  email: string
  roles: string[]
  permissions: string[]
}

// 检查用户是否已登录
export function isAuthenticated(): boolean {
  const userStore = useUserStore()
  return userStore.isLoggedIn
}

// 检查用户是否有指定角色
export function hasRole(roles: string[]): boolean {
  const userStore = useUserStore()
  if (!userStore.userInfo) return false
  
  return roles.some(role => userStore.userInfo.roles.includes(role))
}

// 检查用户是否有指定权限
export function hasPermission(permissions: string[]): boolean {
  const userStore = useUserStore()
  if (!userStore.userInfo) return false
  
  return permissions.some(permission => userStore.userInfo.permissions.includes(permission))
}

// 检查路由权限
export function hasRoutePermission(route: any): boolean {
  const meta = route.meta
  
  // 不需要认证
  if (!meta?.requiresAuth) {
    return true
  }
  
  // 检查登录状态
  if (!isAuthenticated()) {
    return false
  }
  
  // 检查角色权限
  if (meta.roles && !hasRole(meta.roles)) {
    return false
  }
  
  // 检查具体权限
  if (meta.permissions && !hasPermission(meta.permissions)) {
    return false
  }
  
  return true
}

// 过滤有权限的路由
export function filterAsyncRoutes(routes: any[], userInfo: UserInfo): any[] {
  const res: any[] = []
  
  routes.forEach(route => {
    const tmp = { ...route }
    
    if (hasRoutePermission(tmp)) {
      if (tmp.children) {
        tmp.children = filterAsyncRoutes(tmp.children, userInfo)
      }
      res.push(tmp)
    }
  })
  
  return res
}
```

### 2. 路由守卫实现

```typescript
// router/guard.ts
import { Router } from 'vue-router'
import { useUserStore } from '@/stores/user'
import { usePermissionStore } from '@/stores/permission'
import { ElMessage } from 'element-plus'

// 白名单路由
const whiteList = ['/login', '/register', '/', '/articles', '/article']

export function setupRouterGuard(router: Router) {
  router.beforeEach(async (to, from, next) => {
    const userStore = useUserStore()
    const permissionStore = usePermissionStore()
    
    // 显示加载状态
    const loading = ElLoading.service({
      lock: true,
      text: '页面加载中...',
      background: 'rgba(0, 0, 0, 0.7)',
    })
    
    try {
      // 检查是否有 token
      const hasToken = userStore.token
      
      if (hasToken) {
        if (to.path === '/login') {
          // 已登录用户访问登录页，重定向到首页
          next({ path: '/' })
          loading.close()
        } else {
          // 检查用户信息是否已加载
          if (!userStore.userInfo) {
            try {
              // 获取用户信息
              await userStore.getUserInfo()
              
              // 生成可访问路由
              const accessRoutes = await permissionStore.generateRoutes()
              
              // 动态添加路由
              accessRoutes.forEach(route => {
                router.addRoute(route)
              })
              
              // 重新导航到目标路由
              next({ ...to, replace: true })
            } catch (error) {
              // 获取用户信息失败，清除 token 并跳转到登录页
              await userStore.logout()
              ElMessage.error('登录已过期，请重新登录')
              next(`/login?redirect=${to.path}`)
            }
          } else {
            // 用户信息已存在，直接访问
            next()
          }
        }
      } else {
        // 没有 token
        if (whiteList.includes(to.path)) {
          // 白名单路由，直接访问
          next()
        } else {
          // 需要登录的路由，跳转到登录页
          next(`/login?redirect=${to.path}`)
        }
      }
    } catch (error) {
      console.error('路由守卫错误:', error)
      next('/login')
    } finally {
      loading.close()
    }
  })
  
  router.afterEach((to) => {
    // 设置页面标题
    if (to.meta?.title) {
      document.title = `${to.meta.title} - 博客系统`
    }
  })
  
  router.onError((error) => {
    console.error('路由错误:', error)
    ElMessage.error('页面加载失败')
  })
}
```

## 权限状态管理

### 1. 权限 Store

```typescript
// stores/permission.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'
import { asyncRoutes, constantRoutes } from '@/router/routes'
import { filterAsyncRoutes } from '@/utils/permission'
import type { AppRouteRecordRaw } from '@/types/router'

export const usePermissionStore = defineStore('permission', () => {
  const routes = ref<AppRouteRecordRaw[]>([])
  const addRoutes = ref<AppRouteRecordRaw[]>([])
  
  // 生成可访问路由
  const generateRoutes = async (userInfo: any) => {
    let accessedRoutes: AppRouteRecordRaw[]
    
    if (userInfo.roles.includes('admin')) {
      // 管理员可以访问所有路由
      accessedRoutes = asyncRoutes || []
    } else {
      // 普通用户根据权限过滤路由
      accessedRoutes = filterAsyncRoutes(asyncRoutes, userInfo)
    }
    
    routes.value = constantRoutes.concat(accessedRoutes)
    addRoutes.value = accessedRoutes
    
    return accessedRoutes
  }
  
  // 重置路由
  const resetRoutes = () => {
    routes.value = []
    addRoutes.value = []
  }
  
  return {
    routes,
    addRoutes,
    generateRoutes,
    resetRoutes,
  }
})
```

### 2. 用户 Store

```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { getUserInfo, logout } from '@/api/user'
import type { UserInfo } from '@/types/user'

export const useUserStore = defineStore('user', () => {
  const token = ref<string>(localStorage.getItem('token') || '')
  const userInfo = ref<UserInfo | null>(null)
  
  const isLoggedIn = computed(() => !!token.value)
  
  // 设置 token
  const setToken = (newToken: string) => {
    token.value = newToken
    localStorage.setItem('token', newToken)
  }
  
  // 获取用户信息
  const getUserInfoAction = async () => {
    try {
      const data = await getUserInfo()
      userInfo.value = data
      return data
    } catch (error) {
      throw error
    }
  }
  
  // 登出
  const logoutAction = async () => {
    try {
      await logout()
    } catch (error) {
      console.error('登出失败:', error)
    } finally {
      resetUserInfo()
    }
  }
  
  // 重置用户信息
  const resetUserInfo = () => {
    token.value = ''
    userInfo.value = null
    localStorage.removeItem('token')
  }
  
  return {
    token,
    userInfo,
    isLoggedIn,
    setToken,
    getUserInfo: getUserInfoAction,
    logout: logoutAction,
    resetUserInfo,
  }
})
```

## 路由组件实现

### 1. 权限指令

```typescript
// directives/permission.ts
import type { Directive } from 'vue'
import { hasRole, hasPermission } from '@/utils/permission'

// 角色权限指令
export const role: Directive = {
  mounted(el, binding) {
    const { value } = binding
    
    if (value && !hasRole(Array.isArray(value) ? value : [value])) {
      el.parentNode?.removeChild(el)
    }
  },
}

// 权限指令
export const permission: Directive = {
  mounted(el, binding) {
    const { value } = binding
    
    if (value && !hasPermission(Array.isArray(value) ? value : [value])) {
      el.parentNode?.removeChild(el)
    }
  },
}

// 注册指令
export function setupPermissionDirectives(app: any) {
  app.directive('role', role)
  app.directive('permission', permission)
}
```

### 2. 权限组件

```vue
<!-- components/Permission.vue -->
<template>
  <div v-if="hasAccess">
    <slot />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { hasRole, hasPermission } from '@/utils/permission'

interface Props {
  roles?: string[]
  permissions?: string[]
}

const props = withDefaults(defineProps<Props>(), {
  roles: () => [],
  permissions: () => [],
})

const hasAccess = computed(() => {
  if (props.roles.length > 0 && !hasRole(props.roles)) {
    return false
  }
  
  if (props.permissions.length > 0 && !hasPermission(props.permissions)) {
    return false
  }
  
  return true
})
</script>
```

### 3. 路由视图组件

```vue
<!-- components/RouterView.vue -->
<template>
  <router-view v-slot="{ Component, route }">
    <transition name="fade" mode="out-in">
      <keep-alive :include="cachedViews">
        <component :is="Component" :key="route.path" />
      </keep-alive>
    </transition>
  </router-view>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useRoute } from 'vue-router'
import { usePermissionStore } from '@/stores/permission'

const route = useRoute()
const permissionStore = usePermissionStore()

// 需要缓存的页面
const cachedViews = computed(() => {
  return permissionStore.routes
    .filter(route => route.meta?.keepAlive)
    .map(route => route.name)
})
</script>

<style scoped>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

## 动态路由管理

### 1. 路由生成器

```typescript
// utils/routeGenerator.ts
import type { AppRouteRecordRaw } from '@/types/router'

// 将路由配置转换为 Vue Router 格式
export function transformRoute(route: AppRouteRecordRaw): any {
  const { meta, children, ...rest } = route
  
  const transformedRoute = {
    ...rest,
    meta: {
      ...meta,
      // 添加路由标识
      routeId: `${route.name}_${Date.now()}`,
    },
  }
  
  if (children && children.length > 0) {
    transformedRoute.children = children.map(child => transformRoute(child))
  }
  
  return transformedRoute
}

// 生成面包屑导航
export function generateBreadcrumbs(route: any): any[] {
  const breadcrumbs: any[] = []
  
  if (route.meta?.breadcrumb !== false) {
    breadcrumbs.push({
      path: route.path,
      title: route.meta?.title || route.name,
    })
  }
  
  if (route.children) {
    route.children.forEach((child: any) => {
      breadcrumbs.push(...generateBreadcrumbs(child))
    })
  }
  
  return breadcrumbs
}
```

### 2. 路由缓存管理

```typescript
// stores/tagsView.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'
import type { RouteLocationNormalized } from 'vue-router'

export interface TagView {
  path: string
  name: string
  title: string
  meta: any
}

export const useTagsViewStore = defineStore('tagsView', () => {
  const visitedViews = ref<TagView[]>([])
  const cachedViews = ref<string[]>([])
  
  // 添加访问的页面
  const addVisitedView = (route: RouteLocationNormalized) => {
    if (visitedViews.value.some(v => v.path === route.path)) return
    
    visitedViews.value.push({
      path: route.path,
      name: route.name as string,
      title: route.meta?.title || route.name as string,
      meta: route.meta,
    })
  }
  
  // 添加缓存页面
  const addCachedView = (route: RouteLocationNormalized) => {
    if (cachedViews.value.includes(route.name as string)) return
    if (route.meta?.keepAlive) {
      cachedViews.value.push(route.name as string)
    }
  }
  
  // 删除访问的页面
  const delVisitedView = (view: TagView) => {
    const index = visitedViews.value.findIndex(v => v.path === view.path)
    if (index > -1) {
      visitedViews.value.splice(index, 1)
    }
  }
  
  // 删除缓存页面
  const delCachedView = (view: TagView) => {
    const index = cachedViews.value.indexOf(view.name)
    if (index > -1) {
      cachedViews.value.splice(index, 1)
    }
  }
  
  // 清空所有页面
  const delAllViews = () => {
    visitedViews.value = []
    cachedViews.value = []
  }
  
  return {
    visitedViews,
    cachedViews,
    addVisitedView,
    addCachedView,
    delVisitedView,
    delCachedView,
    delAllViews,
  }
})
```

## 错误处理和用户体验

### 1. 错误页面组件

```vue
<!-- views/error/403.vue -->
<template>
  <div class="error-page">
    <div class="error-content">
      <h1>403</h1>
      <h2>访问被拒绝</h2>
      <p>抱歉，您没有权限访问此页面</p>
      <el-button type="primary" @click="goBack">返回上一页</el-button>
      <el-button @click="goHome">返回首页</el-button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useRouter } from 'vue-router'

const router = useRouter()

const goBack = () => {
  router.go(-1)
}

const goHome = () => {
  router.push('/')
}
</script>

<style scoped>
.error-page {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background: #f5f5f5;
}

.error-content {
  text-align: center;
}

.error-content h1 {
  font-size: 120px;
  color: #409eff;
  margin: 0;
}

.error-content h2 {
  font-size: 24px;
  color: #333;
  margin: 20px 0;
}

.error-content p {
  color: #666;
  margin-bottom: 30px;
}
</style>
```

### 2. 权限不足提示

```typescript
// utils/message.ts
import { ElMessage, ElMessageBox } from 'element-plus'

// 权限不足提示
export function showPermissionDenied() {
  ElMessageBox.alert(
    '您没有权限访问此功能，请联系管理员',
    '权限不足',
    {
      confirmButtonText: '确定',
      type: 'warning',
    }
  )
}

// 登录提示
export function showLoginRequired() {
  ElMessageBox.confirm(
    '请先登录后再访问此功能',
    '需要登录',
    {
      confirmButtonText: '去登录',
      cancelButtonText: '取消',
      type: 'info',
    }
  ).then(() => {
    router.push('/login')
  })
}
```

## 总结

前端路由权限控制是确保系统安全性的重要组成部分，需要综合考虑用户体验和系统安全。

**关键要点：**
- 路由元信息设计
- 权限验证逻辑
- 动态路由生成
- 路由守卫实现
- 权限状态管理

**最佳实践：**
1. **权限设计**: 合理设计角色和权限体系
2. **路由管理**: 静态路由和动态路由结合使用
3. **用户体验**: 友好的权限提示和错误处理
4. **性能优化**: 路由懒加载和页面缓存
5. **安全考虑**: 前端权限验证配合后端验证

通过合理的路由权限控制实现，可以为博客系统提供安全、流畅的用户体验。

---

*本文详细介绍了前端路由权限控制的实现原理、设计思路和最佳实践，希望对您的开发工作有所帮助。*
