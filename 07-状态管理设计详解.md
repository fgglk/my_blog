# 状态管理设计详解 - Pinia 状态管理实践

## 问题背景

在博客项目中，需要管理复杂的应用状态，包括用户信息、文章数据、UI状态等。使用 Pinia 作为状态管理库，需要设计合理的状态结构和数据流。

## 状态管理的核心问题

### 1. 状态设计问题
- 状态结构设计
- 状态分类管理
- 状态更新策略
- 状态持久化

### 2. 数据流问题
- 单向数据流
- 状态同步
- 异步状态处理
- 状态依赖关系

### 3. 性能问题
- 状态更新优化
- 组件重渲染控制
- 内存泄漏预防
- 状态缓存策略

## 状态结构设计

### 1. 状态分类

```typescript
// types/store.ts
export interface AppState {
  // 用户相关状态
  user: UserState
  // 文章相关状态
  article: ArticleState
  // 标签相关状态
  tag: TagState
  // UI 相关状态
  ui: UIState
  // 搜索相关状态
  search: SearchState
  // 权限相关状态
  permission: PermissionState
}

export interface UserState {
  token: string
  userInfo: UserInfo | null
  isLoggedIn: boolean
  loading: boolean
}

export interface ArticleState {
  articles: Article[]
  currentArticle: Article | null
  total: number
  loading: boolean
  filters: ArticleFilters
}

export interface TagState {
  tags: Tag[]
  loading: boolean
}

export interface UIState {
  theme: 'light' | 'dark'
  sidebar: {
    collapsed: boolean
    visible: boolean
  }
  loading: {
    global: boolean
    page: boolean
  }
  notifications: Notification[]
}

export interface SearchState {
  keyword: string
  results: Article[]
  total: number
  loading: boolean
  filters: SearchFilters
}

export interface PermissionState {
  routes: RouteRecordRaw[]
  addRoutes: RouteRecordRaw[]
  permissions: string[]
  roles: string[]
}
```

### 2. Store 模块设计

```typescript
// stores/index.ts
import { createPinia } from 'pinia'
import { markRaw } from 'vue'

const pinia = createPinia()

// 添加路由到 pinia 上下文
pinia.use(({ store }) => {
  store.$router = markRaw(router)
  store.$route = markRaw(route)
})

export default pinia
```

## 用户状态管理

### 1. 用户 Store

```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { login, logout, getUserInfo, updateProfile } from '@/api/user'
import type { UserInfo, LoginForm, UpdateProfileForm } from '@/types/user'

export const useUserStore = defineStore('user', () => {
  // 状态
  const token = ref<string>(localStorage.getItem('token') || '')
  const userInfo = ref<UserInfo | null>(null)
  const loading = ref(false)

  // 计算属性
  const isLoggedIn = computed(() => !!token.value)
  const username = computed(() => userInfo.value?.username || '')
  const avatar = computed(() => userInfo.value?.avatar || '')
  const roles = computed(() => userInfo.value?.roles || [])
  const permissions = computed(() => userInfo.value?.permissions || [])

  // 登录
  const loginAction = async (loginForm: LoginForm) => {
    loading.value = true
    try {
      const { token: newToken, user } = await login(loginForm)
      
      // 设置 token
      setToken(newToken)
      
      // 设置用户信息
      userInfo.value = user
      
      // 持久化用户信息
      localStorage.setItem('userInfo', JSON.stringify(user))
      
      return { success: true }
    } catch (error) {
      return { success: false, error }
    } finally {
      loading.value = false
    }
  }

  // 登出
  const logoutAction = async () => {
    loading.value = true
    try {
      await logout()
    } catch (error) {
      console.error('登出失败:', error)
    } finally {
      resetUserInfo()
      loading.value = false
    }
  }

  // 获取用户信息
  const getUserInfoAction = async () => {
    if (!token.value) return null
    
    loading.value = true
    try {
      const user = await getUserInfo()
      userInfo.value = user
      localStorage.setItem('userInfo', JSON.stringify(user))
      return user
    } catch (error) {
      console.error('获取用户信息失败:', error)
      resetUserInfo()
      throw error
    } finally {
      loading.value = false
    }
  }

  // 更新用户信息
  const updateProfileAction = async (profileForm: UpdateProfileForm) => {
    loading.value = true
    try {
      const updatedUser = await updateProfile(profileForm)
      userInfo.value = { ...userInfo.value, ...updatedUser }
      localStorage.setItem('userInfo', JSON.stringify(userInfo.value))
      return updatedUser
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }

  // 设置 token
  const setToken = (newToken: string) => {
    token.value = newToken
    localStorage.setItem('token', newToken)
  }

  // 重置用户信息
  const resetUserInfo = () => {
    token.value = ''
    userInfo.value = null
    localStorage.removeItem('token')
    localStorage.removeItem('userInfo')
  }

  // 初始化用户信息
  const initUserInfo = () => {
    const savedUserInfo = localStorage.getItem('userInfo')
    if (savedUserInfo) {
      try {
        userInfo.value = JSON.parse(savedUserInfo)
      } catch (error) {
        console.error('解析用户信息失败:', error)
        localStorage.removeItem('userInfo')
      }
    }
  }

  return {
    // 状态
    token,
    userInfo,
    loading,
    
    // 计算属性
    isLoggedIn,
    username,
    avatar,
    roles,
    permissions,
    
    // 方法
    login: loginAction,
    logout: logoutAction,
    getUserInfo: getUserInfoAction,
    updateProfile: updateProfileAction,
    setToken,
    resetUserInfo,
    initUserInfo,
  }
})
```

## 文章状态管理

### 1. 文章 Store

```typescript
// stores/article.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { getArticles, getArticle, createArticle, updateArticle, deleteArticle } from '@/api/article'
import type { Article, ArticleFilters, CreateArticleForm, UpdateArticleForm } from '@/types/article'

export const useArticleStore = defineStore('article', () => {
  // 状态
  const articles = ref<Article[]>([])
  const currentArticle = ref<Article | null>(null)
  const total = ref(0)
  const loading = ref(false)
  const filters = ref<ArticleFilters>({
    page: 1,
    pageSize: 20,
    category: '',
    tags: [],
    keyword: '',
    status: 'published',
  })

  // 计算属性
  const hasMore = computed(() => {
    return articles.value.length < total.value
  })

  const currentPage = computed(() => filters.value.page)

  // 获取文章列表
  const fetchArticles = async (newFilters?: Partial<ArticleFilters>) => {
    if (newFilters) {
      filters.value = { ...filters.value, ...newFilters }
    }

    loading.value = true
    try {
      const { data, total: totalCount } = await getArticles(filters.value)
      
      if (filters.value.page === 1) {
        articles.value = data
      } else {
        articles.value.push(...data)
      }
      
      total.value = totalCount
      return data
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }

  // 获取单篇文章
  const fetchArticle = async (id: number) => {
    loading.value = true
    try {
      const article = await getArticle(id)
      currentArticle.value = article
      return article
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }

  // 创建文章
  const createArticleAction = async (articleForm: CreateArticleForm) => {
    loading.value = true
    try {
      const newArticle = await createArticle(articleForm)
      
      // 如果是第一页，添加到列表开头
      if (filters.value.page === 1) {
        articles.value.unshift(newArticle)
        total.value += 1
      }
      
      return newArticle
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }

  // 更新文章
  const updateArticleAction = async (id: number, articleForm: UpdateArticleForm) => {
    loading.value = true
    try {
      const updatedArticle = await updateArticle(id, articleForm)
      
      // 更新列表中的文章
      const index = articles.value.findIndex(article => article.id === id)
      if (index > -1) {
        articles.value[index] = updatedArticle
      }
      
      // 更新当前文章
      if (currentArticle.value?.id === id) {
        currentArticle.value = updatedArticle
      }
      
      return updatedArticle
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }

  // 删除文章
  const deleteArticleAction = async (id: number) => {
    loading.value = true
    try {
      await deleteArticle(id)
      
      // 从列表中移除
      const index = articles.value.findIndex(article => article.id === id)
      if (index > -1) {
        articles.value.splice(index, 1)
        total.value -= 1
      }
      
      // 清除当前文章
      if (currentArticle.value?.id === id) {
        currentArticle.value = null
      }
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }

  // 重置状态
  const resetState = () => {
    articles.value = []
    currentArticle.value = null
    total.value = 0
    filters.value = {
      page: 1,
      pageSize: 20,
      category: '',
      tags: [],
      keyword: '',
      status: 'published',
    }
  }

  return {
    // 状态
    articles,
    currentArticle,
    total,
    loading,
    filters,
    
    // 计算属性
    hasMore,
    currentPage,
    
    // 方法
    fetchArticles,
    fetchArticle,
    createArticle: createArticleAction,
    updateArticle: updateArticleAction,
    deleteArticle: deleteArticleAction,
    resetState,
  }
})
```

## UI 状态管理

### 1. UI Store

```typescript
// stores/ui.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export interface Notification {
  id: string
  type: 'success' | 'warning' | 'error' | 'info'
  title: string
  message: string
  duration?: number
  showClose?: boolean
}

export const useUIStore = defineStore('ui', () => {
  // 主题状态
  const theme = ref<'light' | 'dark'>(
    localStorage.getItem('theme') as 'light' | 'dark' || 'light'
  )

  // 侧边栏状态
  const sidebar = ref({
    collapsed: localStorage.getItem('sidebarCollapsed') === 'true',
    visible: true,
  })

  // 加载状态
  const loading = ref({
    global: false,
    page: false,
  })

  // 通知列表
  const notifications = ref<Notification[]>([])

  // 计算属性
  const isDarkTheme = computed(() => theme.value === 'dark')
  const isSidebarCollapsed = computed(() => sidebar.value.collapsed)

  // 切换主题
  const toggleTheme = () => {
    theme.value = theme.value === 'light' ? 'dark' : 'light'
    localStorage.setItem('theme', theme.value)
    
    // 应用主题到 DOM
    document.documentElement.setAttribute('data-theme', theme.value)
  }

  // 设置主题
  const setTheme = (newTheme: 'light' | 'dark') => {
    theme.value = newTheme
    localStorage.setItem('theme', newTheme)
    document.documentElement.setAttribute('data-theme', newTheme)
  }

  // 切换侧边栏
  const toggleSidebar = () => {
    sidebar.value.collapsed = !sidebar.value.collapsed
    localStorage.setItem('sidebarCollapsed', sidebar.value.collapsed.toString())
  }

  // 设置侧边栏状态
  const setSidebarCollapsed = (collapsed: boolean) => {
    sidebar.value.collapsed = collapsed
    localStorage.setItem('sidebarCollapsed', collapsed.toString())
  }

  // 显示全局加载
  const showGlobalLoading = () => {
    loading.value.global = true
  }

  // 隐藏全局加载
  const hideGlobalLoading = () => {
    loading.value.global = false
  }

  // 显示页面加载
  const showPageLoading = () => {
    loading.value.page = true
  }

  // 隐藏页面加载
  const hidePageLoading = () => {
    loading.value.page = false
  }

  // 添加通知
  const addNotification = (notification: Omit<Notification, 'id'>) => {
    const id = Date.now().toString()
    const newNotification: Notification = {
      id,
      duration: 3000,
      showClose: true,
      ...notification,
    }
    
    notifications.value.push(newNotification)
    
    // 自动移除通知
    if (newNotification.duration && newNotification.duration > 0) {
      setTimeout(() => {
        removeNotification(id)
      }, newNotification.duration)
    }
    
    return id
  }

  // 移除通知
  const removeNotification = (id: string) => {
    const index = notifications.value.findIndex(n => n.id === id)
    if (index > -1) {
      notifications.value.splice(index, 1)
    }
  }

  // 清空所有通知
  const clearNotifications = () => {
    notifications.value = []
  }

  // 初始化主题
  const initTheme = () => {
    document.documentElement.setAttribute('data-theme', theme.value)
  }

  return {
    // 状态
    theme,
    sidebar,
    loading,
    notifications,
    
    // 计算属性
    isDarkTheme,
    isSidebarCollapsed,
    
    // 方法
    toggleTheme,
    setTheme,
    toggleSidebar,
    setSidebarCollapsed,
    showGlobalLoading,
    hideGlobalLoading,
    showPageLoading,
    hidePageLoading,
    addNotification,
    removeNotification,
    clearNotifications,
    initTheme,
  }
})
```

## 搜索状态管理

### 1. 搜索 Store

```typescript
// stores/search.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { searchArticles } from '@/api/search'
import type { Article, SearchFilters } from '@/types/search'

export const useSearchStore = defineStore('search', () => {
  // 状态
  const keyword = ref('')
  const results = ref<Article[]>([])
  const total = ref(0)
  const loading = ref(false)
  const filters = ref<SearchFilters>({
    page: 1,
    pageSize: 20,
    category: '',
    tags: [],
    startDate: '',
    endDate: '',
  })

  // 计算属性
  const hasResults = computed(() => results.value.length > 0)
  const isEmpty = computed(() => !loading.value && results.value.length === 0)

  // 执行搜索
  const performSearch = async (searchKeyword?: string, newFilters?: Partial<SearchFilters>) => {
    if (searchKeyword !== undefined) {
      keyword.value = searchKeyword
    }
    
    if (newFilters) {
      filters.value = { ...filters.value, ...newFilters, page: 1 }
    }

    loading.value = true
    try {
      const { data, total: totalCount } = await searchArticles({
        keyword: keyword.value,
        ...filters.value,
      })
      
      results.value = data
      total.value = totalCount
      
      return data
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }

  // 加载更多搜索结果
  const loadMore = async () => {
    if (loading.value || results.value.length >= total.value) return
    
    filters.value.page += 1
    loading.value = true
    
    try {
      const { data } = await searchArticles({
        keyword: keyword.value,
        ...filters.value,
      })
      
      results.value.push(...data)
    } catch (error) {
      filters.value.page -= 1
      throw error
    } finally {
      loading.value = false
    }
  }

  // 清空搜索结果
  const clearResults = () => {
    keyword.value = ''
    results.value = []
    total.value = 0
    filters.value = {
      page: 1,
      pageSize: 20,
      category: '',
      tags: [],
      startDate: '',
      endDate: '',
    }
  }

  // 设置关键词
  const setKeyword = (newKeyword: string) => {
    keyword.value = newKeyword
  }

  // 设置过滤器
  const setFilters = (newFilters: Partial<SearchFilters>) => {
    filters.value = { ...filters.value, ...newFilters, page: 1 }
  }

  return {
    // 状态
    keyword,
    results,
    total,
    loading,
    filters,
    
    // 计算属性
    hasResults,
    isEmpty,
    
    // 方法
    performSearch,
    loadMore,
    clearResults,
    setKeyword,
    setFilters,
  }
})
```

## 状态持久化

### 1. 持久化插件

```typescript
// plugins/persistedState.ts
import { PiniaPluginContext } from 'pinia'

interface PersistOptions {
  key?: string
  storage?: Storage
  paths?: string[]
}

export function createPersistedState(options: PersistOptions = {}) {
  const {
    key = 'pinia',
    storage = localStorage,
    paths = [],
  } = options

  return ({ store }: PiniaPluginContext) => {
    // 恢复状态
    const savedState = storage.getItem(`${key}-${store.$id}`)
    if (savedState) {
      try {
        const parsedState = JSON.parse(savedState)
        store.$patch(parsedState)
      } catch (error) {
        console.error('恢复状态失败:', error)
      }
    }

    // 监听状态变化
    store.$subscribe((mutation, state) => {
      let stateToPersist = state
      
      // 如果指定了路径，只持久化部分状态
      if (paths.length > 0) {
        stateToPersist = paths.reduce((obj, path) => {
          obj[path] = state[path]
          return obj
        }, {} as any)
      }
      
      storage.setItem(`${key}-${store.$id}`, JSON.stringify(stateToPersist))
    })
  }
}

// 使用示例
import { createPinia } from 'pinia'
import { createPersistedState } from './plugins/persistedState'

const pinia = createPinia()

// 为特定 store 添加持久化
pinia.use(createPersistedState({
  key: 'blog-store',
  paths: ['user.token', 'user.userInfo', 'ui.theme', 'ui.sidebar.collapsed'],
}))
```

### 2. 状态重置

```typescript
// utils/storeReset.ts
import { useUserStore } from '@/stores/user'
import { useArticleStore } from '@/stores/article'
import { useSearchStore } from '@/stores/search'
import { useUIStore } from '@/stores/ui'

export function resetAllStores() {
  const userStore = useUserStore()
  const articleStore = useArticleStore()
  const searchStore = useSearchStore()
  const uiStore = useUIStore()

  // 重置各个 store
  userStore.resetUserInfo()
  articleStore.resetState()
  searchStore.clearResults()
  
  // 保留 UI 状态，不清除主题等设置
  uiStore.clearNotifications()
}
```

## 状态优化

### 1. 状态订阅优化

```typescript
// utils/storeOptimization.ts
import { watch, nextTick } from 'vue'

// 批量更新状态
export function batchUpdate<T extends Record<string, any>>(
  store: T,
  updates: Partial<T>
) {
  const keys = Object.keys(updates)
  
  // 使用 nextTick 确保批量更新
  nextTick(() => {
    keys.forEach(key => {
      if (key in store) {
        store[key] = updates[key]
      }
    })
  })
}

// 防抖更新
export function debounceUpdate<T extends Record<string, any>>(
  store: T,
  key: keyof T,
  value: T[keyof T],
  delay: number = 300
) {
  let timeoutId: NodeJS.Timeout
  
  clearTimeout(timeoutId)
  timeoutId = setTimeout(() => {
    store[key] = value
  }, delay)
}

// 状态变化监听
export function watchStoreState<T>(
  store: T,
  callback: (newState: T, oldState: T) => void,
  options?: { deep?: boolean; immediate?: boolean }
) {
  return watch(
    () => store,
    callback,
    { deep: true, ...options }
  )
}
```

### 2. 状态缓存

```typescript
// utils/storeCache.ts
interface CacheItem<T> {
  data: T
  timestamp: number
  ttl: number
}

class StoreCache {
  private cache = new Map<string, CacheItem<any>>()

  set<T>(key: string, data: T, ttl: number = 5 * 60 * 1000) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl,
    })
  }

  get<T>(key: string): T | null {
    const item = this.cache.get(key)
    if (!item) return null

    const isExpired = Date.now() - item.timestamp > item.ttl
    if (isExpired) {
      this.cache.delete(key)
      return null
    }

    return item.data
  }

  clear() {
    this.cache.clear()
  }

  remove(key: string) {
    this.cache.delete(key)
  }
}

export const storeCache = new StoreCache()
```

## 总结

状态管理是前端应用的核心部分，合理的设计可以提升开发效率和用户体验。

**关键要点：**
- 状态结构设计
- Store 模块化
- 状态持久化
- 性能优化
- 数据流管理

**最佳实践：**
1. **模块化设计**: 按功能模块划分 Store
2. **状态分类**: 明确区分不同类型的状态
3. **持久化策略**: 合理选择需要持久化的状态
4. **性能优化**: 避免不必要的状态更新和重渲染
5. **数据流**: 保持单向数据流，避免状态混乱

通过合理的状态管理设计，可以为博客系统提供高效、可维护的状态管理方案。

---

*本文详细介绍了 Pinia 状态管理的设计思路、实现方法和最佳实践，希望对您的开发工作有所帮助。*
