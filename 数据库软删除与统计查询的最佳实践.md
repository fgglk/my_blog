# 数据库软删除与统计查询的最佳实践

## 引言

在开发博客系统时，我们经常会遇到数据统计不准确的问题。特别是在使用软删除（Soft Delete）机制时，如果不正确处理统计查询，就会出现数据不一致的情况。本文将详细介绍软删除机制的原理、常见问题以及最佳实践。

## 什么是软删除？

软删除是一种数据删除策略，它不会真正从数据库中删除记录，而是通过设置一个标记字段（通常是 `deleted_at`）来表示该记录已被"删除"。

### 软删除的优势

1. **数据安全性**：避免误删重要数据
2. **数据恢复**：可以轻松恢复被"删除"的数据
3. **审计追踪**：保留数据变更历史
4. **业务连续性**：避免级联删除带来的复杂问题

### 软删除的实现

在 Go + GORM 中，软删除通常通过以下方式实现：

```go
type BaseModel struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
}
```

## 常见问题分析

### 问题1：统计查询包含已删除数据

**问题描述**：
在博客系统中，文章分类的统计数据在删除文章后没有减少，导致统计不准确。

**问题原因**：
```sql
-- 错误的查询方式
SELECT 
    c.id,
    c.name,
    COUNT(a.id) as article_count
FROM categories c
LEFT JOIN articles a ON c.id = a.category_id AND a.status = 1
GROUP BY c.id, c.name
```

这个查询没有排除软删除的文章，导致已删除的文章仍然被计入统计。

**解决方案**：
```sql
-- 正确的查询方式
SELECT 
    c.id,
    c.name,
    COUNT(a.id) as article_count
FROM categories c
LEFT JOIN articles a ON c.id = a.category_id 
    AND a.status = 1 
    AND a.deleted_at IS NULL
GROUP BY c.id, c.name
```

### 问题2：关联查询遗漏软删除条件

**问题描述**：
在查询文章及其关联数据时，可能会意外包含已删除的关联记录。

**解决方案**：
```go
// 正确的关联查询
err := global.DB.Preload("Category").
    Preload("Tags").
    Preload("Author").
    Where("status = ? AND deleted_at IS NULL", 1).
    Find(&articles).Error
```

## 最佳实践

### 1. 统一的查询条件

创建一个通用的查询构建器：

```go
func (s *ArticleService) buildActiveQuery() *gorm.DB {
    return global.DB.Where("deleted_at IS NULL")
}

func (s *ArticleService) buildPublishedQuery() *gorm.DB {
    return s.buildActiveQuery().Where("status = ?", 1)
}
```

### 2. 使用 GORM 的 Unscoped 方法

当需要查询包含软删除记录时，使用 `Unscoped()`：

```go
// 查询所有记录（包括软删除的）
var allArticles []Article
global.DB.Unscoped().Find(&allArticles)

// 只查询软删除的记录
var deletedArticles []Article
global.DB.Unscoped().Where("deleted_at IS NOT NULL").Find(&deletedArticles)
```

### 3. 统计查询的最佳实践

```go
func (s *CategoryService) GetCategoryListWithCount() ([]CategoryWithCount, error) {
    var categories []CategoryWithCount
    
    query := `
        SELECT 
            c.id,
            c.name,
            c.slug,
            c.parent_id,
            c.sort,
            c.created_at,
            c.updated_at,
            COUNT(a.id) as article_count
        FROM categories c
        LEFT JOIN articles a ON c.id = a.category_id 
            AND a.status = 1 
            AND a.deleted_at IS NULL
        GROUP BY c.id, c.name, c.slug, c.parent_id, c.sort, c.created_at, c.updated_at
        ORDER BY c.sort DESC, c.id ASC
    `
    
    err := global.DB.Raw(query).Scan(&categories).Error
    return categories, err
}
```

### 4. 事务中的一致性保证

在涉及软删除的操作中，确保数据一致性：

```go
func (s *ArticleService) DeleteArticle(articleID uint, userID uint, isAdmin bool) error {
    // 使用事务确保数据一致性
    tx := global.DB.Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    // 获取文章信息
    var article Article
    if err := tx.Where("id = ?", articleID).First(&article).Error; err != nil {
        tx.Rollback()
        return err
    }

    // 软删除文章
    if err := tx.Delete(&article).Error; err != nil {
        tx.Rollback()
        return err
    }

    // 更新相关统计（如果需要）
    if err := s.updateRelatedStats(tx, article.CategoryID); err != nil {
        tx.Rollback()
        return err
    }

    return tx.Commit().Error
}
```

## 性能优化建议

### 1. 索引优化

为软删除字段创建索引：

```go
DeletedAt gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
```

### 2. 查询优化

避免在 WHERE 条件中使用复杂的函数：

```sql
-- 不推荐
WHERE YEAR(deleted_at) = 2024

-- 推荐
WHERE deleted_at >= '2024-01-01' AND deleted_at < '2025-01-01'
```

### 3. 定期清理

对于长期不需要的软删除数据，可以定期清理：

```go
func (s *ArticleService) CleanupOldDeletedArticles() error {
    // 删除30天前的软删除文章
    cutoffDate := time.Now().AddDate(0, 0, -30)
    
    return global.DB.Unscoped().
        Where("deleted_at < ?", cutoffDate).
        Delete(&Article{}).Error
}
```

## 总结

软删除是一种强大的数据管理策略，但需要谨慎处理统计查询。关键要点包括：

1. **始终在统计查询中排除软删除记录**
2. **使用统一的查询条件构建器**
3. **在事务中保证数据一致性**
4. **合理使用索引优化查询性能**
5. **定期清理过期的软删除数据**

通过遵循这些最佳实践，可以确保软删除机制既能保护数据安全，又不会影响统计查询的准确性。

---

*本文基于实际项目开发经验总结，如有疑问或建议，欢迎讨论交流。*
